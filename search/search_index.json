{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQL Learning Materials","text":"<p>Success</p> <p>SQL scripts that demonstrate various features and concepts.</p> <p>This project contains a bunch of SQL learning materials aimed at different levels of experience and covering a variety of topics. It focuses on just writing <code>SELECT</code> statements so there will be very few resources for anything else.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>The data used in this project is from a couple of sources.</p> <p>The SQL Server instance has the ubiquitous AdventureWorks databases (the transactional one and the analytical one), which are available from various Microsoft pages:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/samples/adventureworks-install-configure</li> <li>https://github.com/Microsoft/sql-server-samples/releases/download/adventureworks</li> </ul> <p>The PostgreSQL instance has the similarly ubiquitous Sakila database, which is available from the following GitHub repo:</p> <ul> <li>https://github.com/jOOQ/sakila/</li> </ul> <p>All credit for the data goes to the respective owners, and these sources should be consulted for any documentation you need around the data.</p>"},{"location":"#contents","title":"Contents","text":"<p>This project has a few different series:</p> <ul> <li>From Excel to SQL, which is aimed at Excel users who want to learn SQL</li> <li>Everything About Joins, which is a comprehensive guide to SQL joins</li> </ul>"},{"location":"everything-about-joins/everything-about-joins/","title":"Everything about joins","text":""},{"location":"everything-about-joins/everything-about-joins/#about-this-course","title":"About this course","text":"<p>Success</p> <p>Everything you need to know about SQL joins \ud83c\udf89</p>"},{"location":"everything-about-joins/everything-about-joins/#the-toolsdata-in-this-course","title":"The tools/data in this course","text":"<p>This course will primarily use DuckDB as the database engine, but will also mention SQLite, PostgreSQL, SQL Server, and Snowflake.</p> <p>The data will be made up for the examples.</p>"},{"location":"everything-about-joins/everything-about-joins/#outline","title":"Outline","text":"<ol> <li>Syntax<ol> <li>SQL-92 rant (ANSI-SQL join syntax)</li> <li>Join fundamentals: <code>INNER</code>, <code>LEFT</code> (<code>RIGHT</code>), <code>FULL</code>, <code>CROSS</code></li> <li>More fundamentals: <code>USING</code>, <code>NATURAL</code></li> <li>The \"timestamp\" join: <code>ASOF</code></li> </ol> </li> <li>Under the hood<ol> <li>...</li> </ol> </li> </ol>"},{"location":"everything-about-joins/syntax/filtering-joins/","title":"The \"filtering\" joins (<code>SEMI</code>, <code>ANTI</code>)","text":"<p>Success</p> <p>The <code>SEMI</code> and <code>ANTI</code> joins are slightly different from typical joins because they're used to filter the rows from the left table based on the presence or absence of a match in the right table.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/","title":"The \"timestamp\" join (<code>ASOF</code>) \u23f1","text":"<p>Success</p> <p>The <code>ASOF</code> join is fantastic for joining two tables with mismatched timestamps, where you want to join on the closest timestamp in the right table to the timestamp in the left table.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#syntax","title":"Syntax","text":"<p>At the time of writing (2024-04-07), the syntax for the <code>ASOF</code> join changes depending on the database engine you're using. However, the general idea is the same across all engines: you're joining two tables based on the closest timestamp in the right table to the timestamp in the left table.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#duckdb","title":"DuckDB","text":"<p>Note</p> <p>The explanation below is adjusted from the DuckDB documentation.</p> <p>In DuckDB, the <code>ASOF</code> keyword is a join modifier just like <code>NATURAL</code>, which means that you can use it with any join type (<code>left</code>, <code>inner</code>, etc.).</p> <p>The <code>ASOF</code> join requires at least one inequality condition on the ordering field. The inequality can be any inequality condition (<code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code>) on any data type, but the most common form is <code>&gt;=</code> on a temporal type. Any other conditions must be equalities (or <code>NOT DISTINCT</code>). This means that the left/right order of the tables is significant.</p> <pre><code>SELECT *\nFROM left_table\n    ASOF [LEFT | INNER | ...] JOIN right_table\n        ON  left_table.id_column = right_table.id_column\n        AND left_table.timestamp_column &gt;= right_table.timestamp_column\n</code></pre> <p><code>ASOF</code> joins can also specify join conditions on matching column names with the <code>USING</code> syntax, but the last attribute in the list must be the inequality, which will be greater than or equal to (<code>&gt;=</code>):</p> <pre><code>SELECT *\nFROM left_table\n    ASOF [LEFT | INNER | ...] JOIN right_table\n        USING (id_column, timestamp_column)\n</code></pre>"},{"location":"everything-about-joins/syntax/timestamp-joins/#snowflake","title":"Snowflake","text":"<p>Snowflake has a more unique syntax for the <code>ASOF</code> join. Rather than be a join modifier, Snowflake treats it as a new join type and introduces the <code>MATCH_CONDITION</code> clause:</p> <pre><code>SELECT *\nFROM left_table\n    ASOF JOIN right_table\n        MATCH_CONDITION (left_table.timestamp_column &gt;= right_table.timestamp_column)\n        ON left_table.id_column = right_table.id_column\n</code></pre> <p>It has an added restriction that the <code>MATCH_CONDITION</code> clause must reference the left column first, then the right column. This isn't a typical for join conditions, hence calling it out here.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#availability","title":"Availability","text":"<p>At the time of writing (2024-04-07), the <code>ASOF</code> join has the following availability:</p> <ul> <li>DuckDB: \u2705</li> <li>SQLite: \u274c</li> <li>PostgreSQL: \u274c</li> <li>SQL Server: \u274c</li> <li>Snowflake: \u2705</li> </ul> <p>Are you aware of any other databases that support the <code>ASOF</code> join?</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#example-finding-the-usd-amount-for-each-transaction-duckdb","title":"Example: finding the USD amount for each transaction (DuckDB)","text":""},{"location":"everything-about-joins/syntax/timestamp-joins/#sample-data","title":"Sample data","text":"<p>Suppose we have two tables, <code>transactions</code> and <code>exchange_rates</code>, with the following data:</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#transactions","title":"<code>transactions</code>","text":"date account amount currency 2023-12-31 A 100.00 GBP 2024-01-01 B 200.00 GBP 2024-01-02 C 300.00 GBP 2024-01-04 A 400.00 GBP 2024-01-07 B 500.00 GBP 2024-01-07 C 600.00 GBP 2024-01-08 A 700.00 GBP 2024-01-10 B 800.00 GBP 2024-01-13 C 900.00 GBP 2024-01-13 A 1000.00 GBP 2024-01-17 B 1100.00 GBP 2024-01-17 C 1200.00 GBP 2024-01-18 A 1300.00 GBP 2024-01-20 B 1400.00 GBP 2024-01-23 C 1500.00 GBP 2024-01-23 A 1600.00 GBP 2024-01-27 B 1700.00 GBP 2024-01-27 C 1800.00 GBP 2024-01-28 A 1900.00 GBP 2024-01-30 B 2000.00 GBP 2024-02-02 C 2100.00 GBP 2024-02-02 A 2200.00 GBP 2024-02-06 B 2300.00 GBP 2024-02-06 C 2400.00 GBP Expand for the object DDL <pre><code>create or replace table transactions(\n    \"date\" date,\n    account varchar(8),\n    amount decimal(10, 2),\n    currency varchar(3),\n    constraint pk__transactions primary key (\"date\", account),\n);\ninsert into transactions\n    values\n        ('2023-12-31', 'A', 100, 'GBP'),\n        ('2024-01-01', 'B', 200, 'GBP'),\n        ('2024-01-02', 'C', 300, 'GBP'),\n        ('2024-01-04', 'A', 400, 'GBP'),\n        ('2024-01-07', 'B', 500, 'GBP'),\n        ('2024-01-07', 'C', 600, 'GBP'),\n        ('2024-01-08', 'A', 700, 'GBP'),\n        ('2024-01-10', 'B', 800, 'GBP'),\n        ('2024-01-13', 'C', 900, 'GBP'),\n        ('2024-01-13', 'A', 1000, 'GBP'),\n        ('2024-01-17', 'B', 1100, 'GBP'),\n        ('2024-01-17', 'C', 1200, 'GBP'),\n        ('2024-01-18', 'A', 1300, 'GBP'),\n        ('2024-01-20', 'B', 1400, 'GBP'),\n        ('2024-01-23', 'C', 1500, 'GBP'),\n        ('2024-01-23', 'A', 1600, 'GBP'),\n        ('2024-01-27', 'B', 1700, 'GBP'),\n        ('2024-01-27', 'C', 1800, 'GBP'),\n        ('2024-01-28', 'A', 1900, 'GBP'),\n        ('2024-01-30', 'B', 2000, 'GBP'),\n        ('2024-02-02', 'C', 2100, 'GBP'),\n        ('2024-02-02', 'A', 2200, 'GBP'),\n        ('2024-02-06', 'B', 2300, 'GBP'),\n        ('2024-02-06', 'C', 2400, 'GBP'),\n;\n</code></pre>"},{"location":"everything-about-joins/syntax/timestamp-joins/#exchange_rates","title":"<code>exchange_rates</code>","text":"date from_currency to_currency rate 2024-01-01 GBP INR 110.0000 2024-01-01 GBP JPY 160.0000 2024-01-01 GBP USD 1.3000 2024-02-01 GBP INR 120.0000 2024-02-01 GBP JPY 170.0000 2024-02-01 GBP USD 1.4000 2024-03-01 GBP INR 100.0000 2024-03-01 GBP JPY 150.0000 2024-03-01 GBP USD 1.2000 Expand for the object DDL <pre><code>create or replace table exchange_rates(\n    \"date\" date,\n    from_currency varchar(3),\n    to_currency varchar(3),\n    rate decimal(10, 4),\n    constraint pk__exchange_rates primary key (\"date\", from_currency, to_currency),\n);\ninsert into exchange_rates\n    values\n        ('2024-01-01', 'GBP', 'INR', 110.0),\n        ('2024-01-01', 'GBP', 'JPY', 160.0),\n        ('2024-01-01', 'GBP', 'USD', 1.3),\n        ('2024-02-01', 'GBP', 'INR', 120.0),\n        ('2024-02-01', 'GBP', 'JPY', 170.0),\n        ('2024-02-01', 'GBP', 'USD', 1.4),\n        ('2024-03-01', 'GBP', 'INR', 100.0),\n        ('2024-03-01', 'GBP', 'JPY', 150.0),\n        ('2024-03-01', 'GBP', 'USD', 1.2),\n;\n</code></pre>"},{"location":"everything-about-joins/syntax/timestamp-joins/#solution","title":"Solution","text":"<p>To find the USD amount for each transaction, we can use the <code>ASOF</code> join to find the closest exchange rate to the transaction date:</p> <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    exchange_rates.rate,\n    transactions.amount * exchange_rates.rate as amount_usd,\nfrom transactions\n    asof left join exchange_rates\n        on  transactions.currency = exchange_rates.from_currency\n        and exchange_rates.to_currency = 'USD'\n        and transactions.date &gt;= exchange_rates.date\norder by\n    transactions.date,\n    transactions.amount\n</code></pre> date account amount rate amount_usd 2023-12-31 A 100.00 null null 2024-01-01 B 200.00 1.3000 260.000000 2024-01-02 C 300.00 1.3000 390.000000 2024-01-04 A 400.00 1.3000 520.000000 2024-01-07 B 500.00 1.3000 650.000000 2024-01-07 C 600.00 1.3000 780.000000 2024-01-08 A 700.00 1.3000 910.000000 2024-01-10 B 800.00 1.3000 1040.000000 2024-01-13 C 900.00 1.3000 1170.000000 2024-01-13 A 1000.00 1.3000 1300.000000 2024-01-17 B 1100.00 1.3000 1430.000000 2024-01-17 C 1200.00 1.3000 1560.000000 2024-01-18 A 1300.00 1.3000 1690.000000 2024-01-20 B 1400.00 1.3000 1820.000000 2024-01-23 C 1500.00 1.3000 1950.000000 2024-01-23 A 1600.00 1.3000 2080.000000 2024-01-27 B 1700.00 1.3000 2210.000000 2024-01-27 C 1800.00 1.3000 2340.000000 2024-01-28 A 1900.00 1.3000 2470.000000 2024-01-30 B 2000.00 1.3000 2600.000000 2024-02-02 C 2100.00 1.4000 2940.000000 2024-02-02 A 2200.00 1.4000 3080.000000 2024-02-06 B 2300.00 1.4000 3220.000000 2024-02-06 C 2400.00 1.4000 3360.000000 <p>Note the <code>NULL</code> values for the first transaction -- this is because there is no exchange rate for the date of that transaction in our <code>exchange_rates</code> table, and we specified <code>ASOF LEFT JOIN</code> so that values without matches are still kept in the result set (like a normal <code>LEFT JOIN</code>!).</p> <p>Exercise</p> <p>Can you re-write this query using the Snowflake syntax?</p> Expand for the Snowflake equivalent <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    exchange_rates.rate,\n    transactions.amount * exchange_rates.rate as amount_usd,\nfrom transactions\n    asof join exchange_rates\n        match_condition (transactions.date &gt;= exchange_rates.date)\n        on transactions.currency = exchange_rates.from_currency\n/* Currently not allowed in `ASOF` join conditions */\nwhere coalesce(exchange_rates.to_currency, 'USD') = 'USD'\norder by\n    transactions.date,\n    transactions.amount\n</code></pre>"},{"location":"everything-about-joins/syntax/timestamp-joins/#traditional-solutions","title":"\"Traditional\" solutions","text":"<p>For comparison, here are a few solutions that illustrate how you might solve this problem without the <code>ASOF</code> join.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#using-a-lateral-join","title":"Using a lateral join","text":"<p>If your database supports lateral \"joins\" (like DuckDB), you can use a lateral join to find the closest exchange rate to the transaction date:</p> <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    rates.rate,\n    transactions.amount * rates.rate as amount_usd,\nfrom transactions,\n    lateral (\n        select rate\n        from exchange_rates\n        where 1=1\n            and transactions.currency = exchange_rates.from_currency\n            and exchange_rates.to_currency = 'USD'\n            and exchange_rates.date &lt;= transactions.date\n        order by exchange_rates.date desc\n        limit 1\n    ) as rates\norder by\n    transactions.date,\n    transactions.amount\n</code></pre> <p>Note that this approach would drop the first transaction from the result set because there is no exchange rate for the date of that transaction in our <code>exchange_rates</code> table. We'll \"fix\" this in the next example.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#using-a-left-lateral-join","title":"Using a left lateral join","text":"<p>To keep the first transaction in the result set when using lateral, we can move the lateral subquery to a left join:</p> <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    rates.rate,\n    transactions.amount * rates.rate as amount_usd,\nfrom transactions\n    left join lateral (\n        select rate\n        from exchange_rates\n        where 1=1\n            and transactions.currency = exchange_rates.from_currency\n            and exchange_rates.to_currency = 'USD'\n            and exchange_rates.date &lt;= transactions.date\n        order by exchange_rates.date desc\n        limit 1\n    ) as rates on 1=1\norder by\n    transactions.date,\n    transactions.amount\n</code></pre>"},{"location":"everything-about-joins/syntax/timestamp-joins/#using-left-join-and-qualify","title":"Using left join and qualify","text":"<p>If your database doesn't have <code>ASOF</code> or lateral joins, you can use a left join and the <code>QUALIFY</code> clause to find the closest exchange rate to the transaction date:</p> <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    exchange_rates.rate,\n    transactions.amount * exchange_rates.rate as amount_usd,\nfrom transactions\n    left join exchange_rates\n        on  transactions.currency = exchange_rates.from_currency\n        and exchange_rates.to_currency = 'USD'\n        and exchange_rates.date &lt;= transactions.date\nqualify 1 = row_number() over (\n    partition by transactions.date, transactions.account\n    order by exchange_rates.date desc\n)\norder by\n    transactions.date,\n    transactions.amount\n</code></pre> <p>If you're using a database that doesn't support the <code>QUALIFY</code> clause, you can wrap the query in a subquery with the <code>ROW_NUMBER()</code> calculation saved to a column and filter on the column in the outer query.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#using-a-left-join-and-correlated-subquery","title":"Using a left join and correlated subquery","text":"<p>If your database doesn't have <code>ASOF</code> joins, lateral joins, or the <code>QUALIFY</code> clause (and you don't want to use <code>ROW_NUMBER()</code> in a subquery), you can use a correlated subquery:</p> <pre><code>select\n    transactions.date,\n    transactions.account,\n    transactions.amount,\n    exchange_rates.rate,\n    transactions.amount * exchange_rates.rate as amount_usd\nfrom transactions\n    left join exchange_rates\n        on  transactions.currency = exchange_rates.from_currency\n        and exchange_rates.to_currency = 'USD'\n        and exchange_rates.date &lt;= transactions.date\nwhere 0=1\n    or exchange_rates.date is null\n    or exchange_rates.date = (\n        select max(\"date\")\n        from exchange_rates as rates_inner\n        where 1=1\n            and exchange_rates.from_currency = rates_inner.from_currency\n            and exchange_rates.to_currency = rates_inner.to_currency\n            and rates_inner.date &lt;= transactions.date\n    )\norder by\n    transactions.date,\n    transactions.amount\n</code></pre> <p>Note that, since this specific example, is only using the <code>rate</code> column from the <code>exchange_rates</code> table, we could have evaluated the subquery in the <code>SELECT</code> clause instead of the <code>FROM</code> clause. However, this would not work if we needed to use more than one column from the <code>exchange_rates</code> table, hence sticking to approaches that cater for multiple columns.</p>"},{"location":"everything-about-joins/syntax/timestamp-joins/#wrap-up","title":"Wrap up","text":"<p>Like with most SQL problems, there are multiple ways to get the output that we want. The <code>ASOF</code> join is just a great way to solve this particular problem, and it significantly reduces the complexity of our SQL code!</p> <p>Note that, also like with most SQL problems, the performance of these queries will depend on the size of the tables and the indexes available. If you're working with large tables, you will need to consider the performance implications of the <code>ASOF</code> approach compared to more \"traditional\" approaches.</p>"},{"location":"from-excel-to-sql/from-excel-to-sql/","title":"From Excel to SQL","text":""},{"location":"from-excel-to-sql/from-excel-to-sql/#about-this-course","title":"About this course","text":"<p>Success</p> <p>SQL for the Excel user \ud83c\udf89</p> <p>Prefer videos? Check out the corresponding YouTube playlist:</p> <ul> <li>https://www.youtube.com/playlist?list=PLEiRgvTilK5rhnVPQ_Tj3Q-CI0rGn_uiD</li> </ul> <p>There are loads of resources online for learning SQL, such as:</p> <ul> <li>W3Schools</li> <li>SQLZoo</li> <li>Mode Analytics</li> <li>Khan Academy</li> <li>Codecademy</li> <li>SQLBolt</li> <li>SQLCourse</li> <li>Analyst Builder</li> <li>DataLemur</li> </ul> <p>...and the list goes on.</p> <p>This course is another one to add to the list, but the focus is coming from an Excel background!</p> <p>Note</p> <p>Some of the information provided here is simplified for the sake of learning. In reality, there may be additional caveats depending on the SQL flavour that you use.</p> <p>There is also plenty of information that is not covered here, even in the advanced concepts section. This is just a starting point, and you are encouraged to check out the documentation for the SQL flavour that you're using \ud83d\udcdd</p>"},{"location":"from-excel-to-sql/from-excel-to-sql/#the-toolsdata-in-this-course","title":"The tools/data in this course","text":"<p>Since this course is aimed at Microsoft Excel users, the \"SQL flavour\" that we'll use is the Microsoft SQL Server dialect (Transact-SQL).</p> <p>Any time a comment is made about how SQL does something, it's referring to the Microsoft SQL Server dialect which may not be the same as other SQL dialects.</p> <p>The data will be the AdventureWorks data. You can access this data for free at a few different places; the following site is recommended since it has an interactive query tool:</p> <ul> <li>https://dbfiddle.uk/</li> </ul> <p>The documentation for the AdventureWorks data is available at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/samples/adventureworks-install-configure</li> </ul> <p>You can download and install applications to run SQL on your own machine. This won't be covered in this course, but there are several alternative guides online such as:</p> <ul> <li>Introduction to SQL Programming for Excel Users - SQL Server Windows Setup</li> </ul> <p>Tip</p> <p>If you're aiming to run SQL at work (assuming there's some SQL at your work to play with \ud83d\ude1d), you'll need to ask around to see what flavour of SQL is being used and what tools/methods for using it are available to you. This is almost entirely at the discretion of your IT department (or similar).</p>"},{"location":"from-excel-to-sql/from-excel-to-sql/#outline","title":"Outline","text":"<ol> <li>Getting started<ol> <li>Setting the context</li> <li>Syntax rules</li> </ol> </li> <li>Main concepts<ol> <li>Gimme data (<code>SELECT</code> and <code>FROM</code>)</li> <li>Filtering (<code>WHERE</code>)</li> <li>Ordering (<code>ORDER BY</code>)</li> <li>Comments (<code>--</code> and <code>/**/</code>)</li> <li><code>TOP</code> and <code>DISTINCT</code></li> <li>Data types</li> <li>Operators</li> <li>Conditional logic (<code>CASE</code> and <code>IIF</code>)</li> <li>Date formatting (<code>FORMAT</code>)</li> <li>Aggregations (<code>GROUP BY</code>)</li> <li>Pivot Tables (<code>ROLLUP</code>)</li> <li>Joins (<code>JOIN</code>)</li> <li>Unions (<code>UNION</code>)</li> <li>Subqueries</li> <li>Window functions (<code>OVER</code>)</li> <li>Logical processing order</li> <li>Style guide</li> </ol> </li> <li>Advanced concepts<ol> <li>Advanced aggregations</li> <li>Correlated subqueries</li> <li>Recursive CTEs</li> </ol> </li> </ol> <p>Warning</p> <p>The advanced concepts are advanced! They are not necessary for most day-to-day SQL usage, but they are good to know about.</p> <p>It is recommended that you practise the main concepts a lot and come back to the advanced concepts later.</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/","title":"Advanced aggregations \ud83e\udd47","text":"<p>Success</p> <p>We saw in the pivot table section that we can extend the <code>GROUP BY</code> clause with the <code>ROLLUP</code> modifier.</p> <p>There are two additional modifiers that we can use to extend the <code>GROUP BY</code> clause with even more flexibility: <code>GROUPING SETS</code> and <code>CUBE</code>.</p> <p>Warning</p> <p>The <code>GROUPING SETS</code> and <code>CUBE</code> modifiers are advanced, and there aren't Excel equivalents for these (without using advanced Excel features).</p> <p>Make sure that you are comfortable with the main concepts before diving into these advanced concepts.</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#lets-start-with-a-pivot-table-recap","title":"Let's start with a pivot table recap","text":"<p>We saw the <code>ROLLUP</code> modifier in the pivot table section which allows us to create subtotals and grand totals in our <code>GROUP BY</code> clause.</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY ROLLUP (\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> <p>The output of this query would include subtotals for each combination of <code>OrderMonth</code> and <code>OnlineOrderFlag</code>, as well as a grand total for each <code>OrderMonth</code> and a grand total for the entire dataset:</p> OrderMonth OnlineOrderFlag TotalSales null null 20996947.7407 \u2190 This is the grand total 2013-01 null 2340061.5521 \u2190 This is the 2013-01 subtotal 2013-01 false 1761132.8322 2013-01 true 578928.7199 2013-02 null 2600218.8667 \u2190 This is the 2013-02 subtotal 2013-02 false 2101152.5476 2013-02 true 499066.3191 2013-03 null 3831605.9389 \u2190 This is the 2013-03 subtotal 2013-03 false 3244501.4287 2013-03 true 587104.5102 2013-04 null 2840711.1734 \u2190 This is the 2013-04 subtotal 2013-04 false 2239156.6675 2013-04 true 601554.5059 2013-05 null 3658084.9461 \u2190 This is the 2013-05 subtotal 2013-05 false 3019173.6253 2013-05 true 638911.3208 2013-06 null 5726265.2635 \u2190 This is the 2013-06 subtotal 2013-06 false 4775809.3027 2013-06 true 950455.9608 <p>One thing you might notice is that we only have the subtotals for <code>OrderMonth</code>. Where are the subtotals for <code>OnlineOrderFlag</code>?</p> <p>As mentioned in the pivot tables section, the <code>ROLLUP</code> modifier follows the same rules as Excel's pivot tables and don't create subtotals for every column.</p> <p>This is where the <code>GROUPING SETS</code> modifier comes in.</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#grouping-sets-allow-us-to-specify-the-subtotals-we-want","title":"<code>GROUPING SETS</code> allow us to specify the subtotals we want","text":"<p>We use the <code>GROUPING SETS</code> modifier in a very similar way to the <code>ROLLUP</code> modifier. We write <code>GROUPING SETS</code> after the <code>GROUP BY</code>, but rather than specify a list of columns, we specify a list of lists of columns.</p> <p>I'll say that again: we specify a list of lists of columns.</p> <p>This is a bit funky \ud83d\ude1d</p> <p>Each list of columns in the <code>GROUPING SETS</code> clause will create a subtotal for the combination of columns in that list. To specify a grand total, we use an empty list.</p> <p>To see this, let's rewrite the previous query using <code>GROUPING SETS</code> instead of <code>ROLLUP</code>:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY GROUPING SETS (\n    (),\n    (FORMAT(OrderDate, 'yyyy-MM')),\n    (FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag)\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> <p>Specifically:</p> <ul> <li><code>()</code> corresponds to the grand total.</li> <li><code>(FORMAT(OrderDate, 'yyyy-MM'))</code> corresponds to the subtotals for <code>OrderMonth</code>.</li> <li><code>(FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag)</code> corresponds to the totals for each combination of <code>OrderMonth</code> and <code>OnlineOrderFlag</code>.</li> </ul> <p>Specifying the subtotals explicitly like this gives us more control over the output of the query. For example, it's super easy to add a subtotal for <code>OnlineOrderFlag</code> by adding another list to the <code>GROUPING SETS</code> clause:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY GROUPING SETS (\n    (),\n    (FORMAT(OrderDate, 'yyyy-MM')),\n    (OnlineOrderFlag),\n    (FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag)\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> OrderMonth OnlineOrderFlag TotalSales null null 20996947.7407 null false 17140926.4040 \u2190 This is new null true 3856021.3367 \u2190 This is new 2013-01 null 2340061.5521 2013-01 false 1761132.8322 2013-01 true 578928.7199 2013-02 null 2600218.8667 2013-02 false 2101152.5476 2013-02 true 499066.3191 2013-03 null 3831605.9389 2013-03 false 3244501.4287 2013-03 true 587104.5102 2013-04 null 2840711.1734 2013-04 false 2239156.6675 2013-04 true 601554.5059 2013-05 null 3658084.9461 2013-05 false 3019173.6253 2013-05 true 638911.3208 2013-06 null 5726265.2635 2013-06 false 4775809.3027 2013-06 true 950455.9608 <p>Since we control exactly which subtotals we want, we can create a much more customised output than we could with <code>ROLLUP</code>!</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#cube-is-like-rollup-but-for-every-combination-of-columns","title":"<code>CUBE</code> is like <code>ROLLUP</code> but for every combination of columns","text":"<p>In the last example above, we added a subtotal for <code>OnlineOrderFlag</code> by adding another list to the <code>GROUPING SETS</code> clause. This meant that we were creating subtotals for every combination of <code>OrderMonth</code> and <code>OnlineOrderFlag</code>:</p> <ul> <li><code>()</code> for neither (the grand total).</li> <li><code>(FORMAT(OrderDate, 'yyyy-MM'))</code> for just <code>OrderMonth</code>.</li> <li><code>(OnlineOrderFlag)</code> for just <code>OnlineOrderFlag</code>.</li> <li><code>(FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag)</code> for both.</li> </ul> <p>With two columns, we write four lists in the <code>GROUPING SETS</code> clause. With three columns, we'd write eight lists. With four columns, we'd write sixteen lists... So this can easily get out of hand!</p> <p>The <code>CUBE</code> modifier is like <code>ROLLUP</code> but for every combination of columns. It's a shortcut for writing out all the combinations of columns in the <code>GROUPING SETS</code> clause. It's also like <code>ROLLUP</code> because we write a list of columns, not a list of lists of columns.</p> <p>To see this, let's rewrite the previous query using <code>CUBE</code> instead of <code>GROUPING SETS</code>:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY CUBE (\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> <p>This will give us the same output as the previous query, but we didn't have to write out all the combinations of columns in the <code>GROUPING SETS</code> clause.</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#we-can-still-use-groupinggrouping_id-to-identify-subtotals","title":"We can still use <code>GROUPING</code>/<code>GROUPING_ID</code> to identify subtotals","text":"<p>Like with <code>ROLLUP</code>, we can use the <code>GROUPING</code> and <code>GROUPING_ID</code> functions to identify which columns are subtotals. For example, here are the same queries as above but with the <code>GROUPING_ID</code> function added to the <code>SELECT</code> clause (they have the same output, so only one is shown):</p> <pre><code>SELECT\n    GROUPING_ID(FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag) AS GroupingId,\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY GROUPING SETS (\n    (),\n    (FORMAT(OrderDate, 'yyyy-MM')),\n    (OnlineOrderFlag),\n    (FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag)\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> <pre><code>SELECT\n    GROUPING_ID(FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag) AS GroupingId,\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY CUBE (\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> GroupingId OrderMonth OnlineOrderFlag TotalSales 3 null null 20996947.7407 2 null false 17140926.4040 2 null true 3856021.3367 1 2013-01 null 2340061.5521 0 2013-01 false 1761132.8322 0 2013-01 true 578928.7199 1 2013-02 null 2600218.8667 0 2013-02 false 2101152.5476 0 2013-02 true 499066.3191 1 2013-03 null 3831605.9389 0 2013-03 false 3244501.4287 0 2013-03 true 587104.5102 1 2013-04 null 2840711.1734 0 2013-04 false 2239156.6675 0 2013-04 true 601554.5059 1 2013-05 null 3658084.9461 0 2013-05 false 3019173.6253 0 2013-05 true 638911.3208 1 2013-06 null 5726265.2635 0 2013-06 false 4775809.3027 0 2013-06 true 950455.9608"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#cubes-are-actually-a-well-known-concept","title":"\"Cubes\" are actually a well-known concept","text":"<p>Warning</p> <p>This is no longer an SQL concept; this is a general concept in mathematics and computer science.</p> <p>The <code>CUBE</code> modifier creates what's known as an Online Analytical Processing (OLAP) cube.</p> <ul> <li>https://en.wikipedia.org/wiki/OLAP_cube</li> </ul> <p>These are used in data warehousing and business intelligence to enable more performant reporting and analytics. They're a bit more advanced than what we're covering here, but it's good to know that the SQL <code>CUBE</code> modifier is based on a well-known concept.</p> <p>Tip</p> <p>If you've used Excel's Power Pivot, you've already used OLAP cubes!</p> <p>Power Pivot creates OLAP cubes behind the scenes so that using the power functions (like <code>CUBEVALUE</code>) can just \"lookup\" from these OLAP cubes.</p>"},{"location":"from-excel-to-sql/advanced-concepts/advanced-aggregations/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on <code>GROUPING SETS</code> and <code>CUBE</code> at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-group-by-transact-sql#group-by-grouping-sets--</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-group-by-transact-sql#group-by-cube--</li> </ul>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/","title":"Correlated subqueries \ud83c\udf10","text":"<p>Success</p> <p>Correlated subqueries are a great way to \"run a subquery\" for each row in a table.</p> <p>This can be slow if used inappropriately, but there are some great places to use this!</p> <p>Warning</p> <p>Correlated subqueries are advanced, and there aren't Excel equivalents for them.</p> <p>Make sure that you are comfortable with the main concepts before diving into these advanced concepts.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#correlated-subqueries-run-a-subquery-for-each-row-in-a-table","title":"Correlated subqueries \"run a subquery\" for each row in a table","text":"<p>We saw subqueries in the subqueries section, so what makes one \"correlated\"?</p> <p>A subquery becomes a \"correlated subquery\" if it references a column from a table in the outer query.</p> <p>The subquery is then \"run\" for each row in the referenced column.</p> <p>This can take a bit of getting used to, but it's a powerful tool when used appropriately.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#converting-joins-into-a-correlated-subquery","title":"Converting joins into a correlated subquery","text":"<p>Warning</p> <p>These are contrived examples to demonstrate the concept. You should stick to using <code>JOIN</code> for this kind of operation! \ud83d\ude1d</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-left-join-department","title":"<code>Employee LEFT JOIN Department</code>","text":"<p>To ease into the concept, we'll see how we could convert a <code>JOIN</code> into a correlated subquery.</p> <p>We saw the following query in the <code>Employee LEFT JOIN Department</code> part of the joins section:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName\nFROM Employee\n    LEFT JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n;\n</code></pre> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales 2 Bob 1 Sales 3 Charlie 2 Marketing 4 Dave 2 Marketing 5 Eve 3 null <p>In this example, we're finding the <code>DepartmentName</code> in the <code>Department</code> table that matches the <code>DepartmentID</code> for each employee in the <code>Employee</code> table.</p> <p>We could convert this into a correlated subquery like so:</p> <pre><code>SELECT\n    EmployeeID,\n    EmployeeName,\n    DepartmentID,\n    (\n        SELECT DepartmentName\n        FROM Department\n        WHERE Department.DepartmentID = Employee.DepartmentID\n    ) AS DepartmentName\nFROM Employee\n;\n</code></pre> <p>This isn't just a normal subquery: the <code>WHERE</code> clause references the <code>Employee</code> table which is outside the subquery!</p> <p>Let's break down what's happening with each row in this table.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-1","title":"Employee 1","text":"<p>The first row is employee 1:</p> EmployeeID EmployeeName DepartmentID 1 Alice 1 <p>Their <code>DepartmentID</code> is 1, so SQL will run the following subquery to find the <code>DepartmentName</code>:</p> <pre><code>SELECT DepartmentName\nFROM Department\nWHERE Department.DepartmentID = 1\n;\n</code></pre> DepartmentName Sales <p>Therefore, the value <code>Sales</code> will be used for the <code>DepartmentName</code> for Alice.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-2","title":"Employee 2","text":"<p>The second row is employee 2:</p> EmployeeID EmployeeName DepartmentID 2 Bob 1 <p>Their <code>DepartmentID</code> is also 1, so SQL will run the exact same subquery to find the <code>DepartmentName</code>; this means that Bob will also have <code>Sales</code> as their <code>DepartmentName</code>.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-3","title":"Employee 3","text":"<p>The third row is employee 3:</p> EmployeeID EmployeeName DepartmentID 3 Charlie 2 <p>Their <code>DepartmentID</code> is 2, so SQL will run the following subquery to find the <code>DepartmentName</code>:</p> <pre><code>SELECT DepartmentName\nFROM Department\nWHERE Department.DepartmentID = 2\n;\n</code></pre> DepartmentName Marketing <p>Therefore, the value <code>Marketing</code> will be used for the <code>DepartmentName</code> for Charlie.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-4","title":"Employee 4","text":"<p>The fourth row is employee 4:</p> EmployeeID EmployeeName DepartmentID 4 Dave 2 <p>Their <code>DepartmentID</code> is also 2, so SQL will run the exact same subquery to find the <code>DepartmentName</code>; this means that Dave will also have <code>Marketing</code> as their <code>DepartmentName</code>.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-5","title":"Employee 5","text":"<p>The fifth row is employee 5:</p> EmployeeID EmployeeName DepartmentID 5 Eve 3 <p>Their <code>DepartmentID</code> is 3, so SQL will run the following subquery to find the <code>DepartmentName</code>:</p> <pre><code>SELECT DepartmentName\nFROM Department\nWHERE Department.DepartmentID = 3\n;\n</code></pre> <p>This subquery will return no rows, so the <code>NULL</code> value will be used for the <code>DepartmentName</code> for Eve.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#putting-it-all-together","title":"Putting it all together","text":"<p>When we put all of these rows together, we get the following result:</p> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales 2 Bob 1 Sales 3 Charlie 2 Marketing 4 Dave 2 Marketing 5 Eve 3 null <p>This is indeed identical to the result we got from the <code>LEFT JOIN</code> query!</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#what-about-the-other-join-examples","title":"What about the other join examples?","text":"<p>We saw two other join examples in the joins section:</p> <ul> <li>An inner join: Employee INNER JOIN Department</li> <li>A left join with multiple matches: Employee LEFT JOIN Address</li> </ul> <p>Do you think we could convert these into correlated subqueries, too?</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-inner-join-department","title":"Employee INNER JOIN Department","text":"<p>If we try to convert the inner join into a correlated subquery, we get exactly the same result as the <code>LEFT JOIN</code> example unless we explicitly filter out the <code>NULL</code> values after the subquery.</p> <p>This means that correlated subqueries are more like <code>LEFT JOIN</code> than <code>INNER JOIN</code> in this context.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-left-join-address","title":"Employee LEFT JOIN Address","text":"<p>If we try to convert the left join with multiple matches into a correlated subquery, we'd end up with an error.</p> <p>This is because the subquery would return two rows for Eve, and subqueries used to define columns are only allowed to return a single value.</p> <p>This is a good example of why correlated subqueries are less appropriate for joins!</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#using-correlated-subqueries-for-filtering","title":"Using correlated subqueries for filtering","text":"<p>The examples above were contrived to demonstrate the concept, but they're not the best use cases for correlated subqueries.</p> <p>The most common place that you'll see correlated subqueries being used is in the <code>WHERE</code> clause; these usually come in two forms:</p> <ul> <li>Relativity tests</li> <li>Existence tests</li> </ul>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#using-correlated-subqueries-for-relativity-tests","title":"Using correlated subqueries for relativity tests","text":"<p>It's typical to see correlated subqueries to be used to get the latest position of a record in a table that holds historical data.</p> <p>For example, the <code>HumanResources.EmployeeDepartmentHistory</code> table holds the history of an employee's department. Let's take a look at the rows corresponding to employees 4, 16, 224, 234, and 250:</p> <pre><code>SELECT\n    BusinessEntityID,\n    DepartmentID,\n    StartDate,\n    EndDate\nFROM HumanResources.EmployeeDepartmentHistory\nWHERE BusinessEntityID IN (4, 16, 224, 234, 250)\nORDER BY BusinessEntityID, StartDate\n;\n</code></pre> BusinessEntityID DepartmentID StartDate EndDate 4 1 2007-12-05 2010-05-30 4 2 2010-05-31 null 16 5 2007-12-20 2009-07-14 16 4 2009-07-15 null 224 7 2009-01-07 2011-08-31 224 8 2011-09-01 null 234 10 2009-01-31 2013-11-13 234 16 2013-11-14 null 250 4 2011-02-25 2011-07-30 250 13 2011-07-31 2012-07-14 250 5 2012-07-15 null <p>This table is nice for finding the latest department for each employee because we can just filter the rows where <code>EndDate</code> is <code>NULL</code>, but what if we didn't have the <code>EndDate</code> column and had to rely on just the <code>StartDate</code>?</p> <p>We could use a correlated subquery to find the latest <code>StartDate</code> for each employee, and then use that to filter the rows:</p> <pre><code>SELECT\n    BusinessEntityID,\n    DepartmentID,\n    StartDate\nFROM HumanResources.EmployeeDepartmentHistory AS History\nWHERE BusinessEntityID IN (4, 16, 224, 234, 250)\n  AND StartDate = (\n    SELECT MAX(StartDate)\n    FROM HumanResources.EmployeeDepartmentHistory AS InnerHistory\n    WHERE InnerHistory.BusinessEntityID = History.BusinessEntityID\n  )\n;\n</code></pre> <p>This is a bit more complex than the previous examples!</p> <p>Not only is the subquery correlated, but it's also using an aggregate function (<code>MAX</code>) to find the latest <code>StartDate</code> for each employee.</p> <p>Let's break down what's happening with each row in this table.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-4_1","title":"Employee 4","text":"<p>The first employee is 4, and they have two rows:</p> BusinessEntityID DepartmentID StartDate 4 1 2007-12-05 4 2 2010-05-31 <p>We know that we want to keep the row with the latest <code>StartDate</code>.</p> <p>A correlated subquery is run for each row in the <code>EmployeeDepartmentHistory</code> table, so the subquery is run twice for employee 4.</p> <p>The subquery that is run for this employee (for both their rows) is:</p> <pre><code>SELECT MAX(StartDate)\nFROM HumanResources.EmployeeDepartmentHistory AS InnerHistory\nWHERE InnerHistory.BusinessEntityID = 4\n;\n</code></pre> MAX(StartDate) 2010-05-31 <p>When the subquery is run for the first row, the <code>StartDate</code> is <code>2007-12-05</code>. This is not the result of the subquery, so the row is discarded.</p> <p>Conversely, when the subquery is run for the second row, the <code>StartDate</code> is <code>2010-05-31</code> so this second row is kept.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-16","title":"Employee 16","text":"<p>The second employee is 16:</p> BusinessEntityID DepartmentID StartDate 16 5 2007-12-20 16 4 2009-07-15 <p>Similar to employee 4, a correlated subquery is run for each row in the <code>EmployeeDepartmentHistory</code> table, so the subquery is also run twice for employee 16.</p> <p>The subquery that is run for this employee (for both their rows) is:</p> <pre><code>SELECT MAX(StartDate)\nFROM HumanResources.EmployeeDepartmentHistory AS InnerHistory\nWHERE InnerHistory.BusinessEntityID = 16\n;\n</code></pre> MAX(StartDate) 2009-07-15 <p>When the subquery is run for the first row, the <code>StartDate</code> is <code>2007-12-20</code>. This is not the result of the subquery, so the row is discarded.</p> <p>Conversely, when the subquery is run for the second row, the <code>StartDate</code> is <code>2010-05-31</code> so this second row is kept.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employees-224-and-234","title":"Employees 224 and 234","text":"<p>Like the previous employees, employees 224 and 234 each have two rows, so the subquery is run twice for each of them too.</p> <p>In both cases, the second row per employee is kept because it has the latest <code>StartDate</code>.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#employee-250","title":"Employee 250","text":"<p>The fifth employee is 250:</p> BusinessEntityID DepartmentID StartDate 250 4 2011-02-25 250 13 2011-07-31 250 5 2012-07-15 <p>This employee has three rows, so the subquery is run three times for them.</p> <p>The subquery that is run for this employee (for all three of their rows) is:</p> <pre><code>SELECT MAX(StartDate)\nFROM HumanResources.EmployeeDepartmentHistory AS InnerHistory\nWHERE InnerHistory.BusinessEntityID = 250\n;\n</code></pre> MAX(StartDate) 2012-07-15 <p>When the subquery is run for the first row, the <code>StartDate</code> is <code>2011-02-25</code>. This is not the result of the subquery, so the row is discarded.</p> <p>When the subquery is run for the second row, the <code>StartDate</code> is <code>2011-07-31</code>. Again, this is not the result of the subquery, so the row is discarded.</p> <p>Finally, when the subquery is run for the third row, the <code>StartDate</code> is <code>2012-07-15</code> so this third row is kept.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#putting-it-all-together_1","title":"Putting it all together","text":"<p>When we put all of these rows together, we get the following result:</p> BusinessEntityID DepartmentID StartDate 4 2 2010-05-31 16 4 2009-07-15 224 8 2011-09-01 234 16 2013-11-14 250 5 2012-07-15 <p>Tip</p> <p>There are other ways (not using correlated subqueries) to achieve this result, too. Can you think of any?</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#using-correlated-subqueries-for-existence-tests","title":"Using correlated subqueries for existence tests","text":"<p>Another common place that you'll see correlated subqueries being used is to check whether a record exists.</p> <p>In this case, the <code>EXISTS</code> keyword is used with the subquery to tell SQL to do the existence test.</p> <p>For example, we could check which people in the <code>Person.Person</code> table have a record in the <code>HumanResources.JobCandidate</code> table:</p> <pre><code>SELECT\n    BusinessEntityID,\n    FirstName,\n    LastName\nFROM Person.Person\nWHERE EXISTS (\n    SELECT *\n    FROM HumanResources.JobCandidate\n    WHERE JobCandidate.BusinessEntityID = Person.BusinessEntityID\n)\n;\n</code></pre> BusinessEntityID FirstName LastName 212 Peng Wu 274 Stephen Jiang <p>As per the Microsoft documentation:</p> <p>Notice that subqueries that are introduced with <code>EXISTS</code> are a bit different from other subqueries in the following ways:</p> <ul> <li>The keyword <code>EXISTS</code> isn't preceded by a column name, constant, or other expression.</li> <li>The select list of a subquery introduced by <code>EXISTS</code> almost always consists of an asterisk (<code>*</code>). There's no reason to list column names because you're just testing whether rows that meet the conditions specified in the subquery exist.</li> </ul> <p>The <code>EXISTS</code> keyword is important because frequently there's no alternative formulation without subqueries. Although some queries that are created with <code>EXISTS</code> can't be expressed any other way, many queries can use <code>IN</code> or a comparison operator modified by <code>ANY</code> or <code>ALL</code> to achieve similar results.</p> <p>Our example is, in fact, an example of a query that can be expressed using <code>IN</code> instead of <code>EXISTS</code>:</p> <pre><code>SELECT\n    BusinessEntityID,\n    FirstName,\n    LastName\nFROM Person.Person\nWHERE BusinessEntityID IN (\n    SELECT BusinessEntityID\n    FROM HumanResources.JobCandidate\n)\n;\n</code></pre> <p>So, what's an example of a query that can't be expressed using <code>IN</code> instead of <code>EXISTS</code>?</p> <p>It's rare, but you'd need <code>EXISTS</code> over <code>IN</code> to evaluate more complex conditions that can't be boiled down to an equality test.</p> <p>For example, the following query can't be expressed using <code>IN</code>:</p> <pre><code>SELECT\n    BusinessEntityID,\n    FirstName,\n    LastName,\n    ModifiedDate\nFROM Person.Person\nWHERE EXISTS (\n    SELECT *\n    FROM HumanResources.JobCandidate\n    WHERE JobCandidate.BusinessEntityID = Person.BusinessEntityID\n      AND JobCandidate.ModifiedDate &gt; Person.ModifiedDate\n)\n;\n</code></pre> <p>This query checks for people who have a record in the <code>HumanResources.JobCandidate</code> table that was modified more recently than their record in the <code>Person.Person</code> table.</p> <p>This can't be expressed using <code>IN</code> because of the <code>JobCandidate.ModifiedDate &gt; Person.ModifiedDate</code> condition.</p> <p>This could, however, be expressed using a <code>LEFT JOIN</code> and a <code>WHERE</code> clause:</p> <pre><code>SELECT\n    Person.BusinessEntityID,\n    Person.FirstName,\n    Person.LastName,\n    Person.ModifiedDate\nFROM Person.Person\n    LEFT JOIN HumanResources.JobCandidate\n        ON JobCandidate.BusinessEntityID = Person.BusinessEntityID\nWHERE JobCandidate.BusinessEntityID IS NOT NULL\n  AND JobCandidate.ModifiedDate &gt; Person.ModifiedDate\n;\n</code></pre> <p>Like with many SQL problems, the approach that you take will depend on the context, the performance of the approaches, and the readability of the code.</p> <p>In this particular case, the <code>LEFT JOIN</code> is more performant than the <code>EXISTS</code> approach (on my personal computer, averaging 100,000 runs):</p> <ul> <li>The <code>LEFT JOIN</code> approach takes approximately 0.88 milliseconds to run (44%)</li> <li>The <code>EXISTS</code> approach takes approximately 1.11 milliseconds to run (56%)</li> </ul> <p>However, the <code>EXISTS</code> approach is slightly more readable (in my opinion), so both approached have pros and cons.</p> <p>Tip</p> <p>You'll encounter several ways to achieve the same output in SQL. There's rarely a \"right\" way to do something, so to figure out which approach you take, you should consider several things like:</p> <ul> <li>The performance of the code</li> <li>The readability of the code</li> <li>The extensibility of the code</li> <li>The preferences of your team/company</li> <li>The tools that you have available to you</li> </ul> <p>This is not a complete list and there are many other things to consider, but it's a good starting point.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#a-quick-note-for-the-programmers","title":"A quick note for the programmers","text":"<p>Warning</p> <p>If you've never done any programming before, skip this bit!</p> <p>If you've used other programming languages, you might be thinking that correlated subqueries are similar to loops. You'd be right!</p> <p>Correlated subqueries can be thought of as for-loops that run for each row in a table.</p> <p>This is why correlated subqueries can be slow if used inappropriately: they can run a lot of times!</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#an-extra-example-to-get-the-brain-juices-flowing","title":"An extra example to get the brain juices flowing","text":"<p>This example is taken from the following article:</p> <ul> <li>https://buttondown.email/jaffray/archive/sql-scoping-is-surprisingly-subtle-and-semantic/</li> </ul> <p>Suppose we have the following tables:</p> <p><code>aa</code></p> a 1 2 3 <p><code>xx</code></p> x 10 20 30 <p>What do you think the results of the following queries are?</p> <pre><code>SELECT (SELECT TOP 1 SUM(1)     FROM xx) FROM aa;\nSELECT (SELECT TOP 1 SUM(a)     FROM xx) FROM aa;\nSELECT (SELECT TOP 1 SUM(x)     FROM xx) FROM aa;\nSELECT (SELECT TOP 1 SUM(a + x) FROM xx) FROM aa;\n</code></pre> <p>Here are the results:</p> Expand to show the results <code>SELECT (SELECT TOP 1 SUM(1) FROM xx) FROM aa</code> 3 3 3 <code>SELECT (SELECT TOP 1 SUM(a) FROM xx) FROM aa</code> 6 <code>SELECT (SELECT TOP 1 SUM(x) FROM xx) FROM aa</code> 60 60 60 <code>SELECT (SELECT TOP 1 SUM(a + x) FROM xx) FROM aa</code> 63 66 69 <p>Weird, right? \ud83e\udd2f</p> <p>See if you can wrap your head around what's going on here, and then check out the article linked above for a great explanation of what's happening.</p>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#the-sql-for-running-this-example","title":"The SQL for running this example","text":"<p>This data is not in the AdventureWorks database, so you can run this example using the SQL below (uncomment the line you want to run):</p> <pre><code>WITH\n\naa AS (\n    SELECT *\n    FROM (VALUES (1), (2), (3)) AS t(a)\n),\nxx AS (\n    SELECT *\n    FROM (VALUES (10), (20), (30)) AS t(x)\n)\n\nSELECT (SELECT TOP 1 SUM(1)     FROM xx) FROM aa\n-- SELECT (SELECT TOP 1 SUM(a)     FROM xx) FROM aa\n-- SELECT (SELECT TOP 1 SUM(x)     FROM xx) FROM aa\n-- SELECT (SELECT TOP 1 SUM(a + x) FROM xx) FROM aa\n;\n</code></pre>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on correlated subqueries at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/relational-databases/performance/subqueries#correlated</li> </ul>"},{"location":"from-excel-to-sql/advanced-concepts/correlated-subqueries/#similarity-to-cross-apply","title":"Similarity to <code>CROSS APPLY</code>","text":"<p>There is a similarity between correlated subqueries and <code>CROSS APPLY</code>. This is outside the scope of this course, but you can read more about it at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/from-transact-sql#using-apply</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/from-transact-sql#k-use-apply</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/from-transact-sqll-use-cross-apply</li> </ul>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/","title":"Recursive CTEs \ud83d\udd01","text":"<p>Success</p> <p>Recursive CTEs are a great way to generate data and to flatten hierarchical data.</p> <p>Warning</p> <p>Recursive CTEs are advanced, and while there is almost an Excel equivalent for one type of recursive CTE, the Excel equivalent is not as flexible as the SQL version.</p> <p>Make sure that you are comfortable with the main concepts before diving into these advanced concepts.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#a-recursive-cte-is-one-that-references-itself","title":"A recursive CTE is one that references itself","text":"<p>Note</p> <p>When you use a recursive CTE, it will keep \"re-running\"/iterating the CTE and adding new rows until the CTE is told to stop.</p> <p>We saw in the subqueries section that subqueries can be defined in the <code>WITH</code> clause at the top of a query:</p> <pre><code>WITH Orders AS (\n    SELECT\n        FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n        TotalDue\n    FROM Sales.SalesOrderHeader\n)\n\nSELECT\n    OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Orders\nWHERE OrderMonth IN ('2013-01', '2013-02', '2013-03')\nGROUP BY OrderMonth\nORDER BY OrderMonth\n;\n</code></pre> <p>The <code>Orders</code> CTE references the <code>Sales.SalesOrderHeader</code> table, which is then referenced by the <code>SELECT</code> statement.</p> <pre><code>flowchart LR\n    A[Sales.SalesOrderHeader] --&gt; B[Orders] --&gt; C[SELECT]</code></pre> <p>A recursive CTE is one that references itself. This sounds a bit weird, but it has two main uses:</p> <ol> <li>To generate rows of data, e.g. a sequence of numbers or a date range</li> <li>To flatten hierarchical data, e.g. an organisation's structure</li> </ol>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-shape-of-a-recursive-cte","title":"The \"shape\" of a recursive CTE","text":"<p>We'll use the following recursive CTE as an example. For now, we'll just focus on how it's written and will explain what it does later.</p> <pre><code>WITH Numbers AS (\n        SELECT 1 AS Number\n    UNION ALL\n        SELECT Number + 1\n        FROM Numbers\n        WHERE Number &lt; 5\n)\n\nSELECT *\nFROM Numbers\n;\n</code></pre> Number 1 2 3 4 5 <p>There are four parts to a recursive CTE:</p> <ol> <li>The anchor <code>SELECT</code> statement</li> <li>The <code>UNION ALL</code> keywords</li> <li>The recursive <code>SELECT</code> statement</li> <li>The termination condition in the <code>WHERE</code> clause</li> </ol>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-anchor-select-statement","title":"The anchor <code>SELECT</code> statement","text":"<p>For a CTE to be able to reference itself, it has to have a starting point \ud83d\ude1d</p> <p>In the example above, the starting point/anchor statement is:</p> <pre><code>SELECT 1 AS Number\n</code></pre> <p>This creates a single row with a single column whose value is <code>1</code>.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-union-all-keywords","title":"The <code>UNION ALL</code> keywords","text":"<p>A recursive CTE will append new rows to the bottom of the existing rows, so it needs a <code>UNION</code>.</p> <p>However, you must use <code>UNION ALL</code> and not just <code>UNION</code>. This is a requirement of SQL, not just a recommendation.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-recursive-select-statement","title":"The recursive <code>SELECT</code> statement","text":"<p>The recursive <code>SELECT</code> statement is the one that references the CTE itself.</p> <p>In the example above, the recursive statement is:</p> <pre><code>SELECT Number + 1\nFROM Numbers\nWHERE Number &lt; 5\n</code></pre> <p>The <code>SELECT</code> clause in this statement contains the logic that you want to apply with each \"re-run\"/iteration. In this case, we're adding <code>1</code> to the <code>Number</code> column.</p> <p>The <code>FROM</code> clause is explicitly where we reference the CTE itself. If we don't reference the CTE itself within the CTE, it won't be recursive \ud83d\ude04</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-termination-condition-in-the-where-clause","title":"The termination condition in the <code>WHERE</code> clause","text":"<p>The <code>WHERE</code> clause in the recursive <code>SELECT</code> statement is the condition that tells the CTE to stop.</p> <p>This is super important: if you don't have a termination condition, the CTE will not stop running!</p> <p>In the example above, the termination condition is:</p> <pre><code>WHERE Number &lt; 5\n</code></pre> <p>This tells the CTE to stop when the <code>Number</code> column is less than <code>5</code>. Note that, because of the way that SQL processes the <code>WHERE</code> clause, the last loop will be when <code>Number</code> is <code>4</code> but the <code>SELECT</code> clause will still add <code>1</code> to it, so the final number in <code>Number</code> will be <code>5</code>.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#putting-it-all-together","title":"Putting it all together","text":"<p>The query below is the same as the one above, but it has comments to show where each part of the recursive CTE is.</p> <pre><code>WITH Numbers AS (\n        /* 1. The anchor SELECT statement */\n        SELECT 1 AS Number\n    /* 2. The UNION ALL keywords */\n    UNION ALL\n        /* 3. The recursive SELECT statement */\n        SELECT Number + 1\n        FROM Numbers\n        /* 4. The termination condition in the WHERE clause */\n        WHERE Number &lt; 5\n)\n\nSELECT *\nFROM Numbers\n;\n</code></pre> <p>Warning</p> <p>In some SQL flavours, you have to explicitly write <code>RECURSIVE</code> after the <code>WITH</code> keyword to tell SQL that the CTE is recursive.</p> <p>This is not necessary (and not even allowed!) in Microsoft SQL Server.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#generating-data-with-a-recursive-cte","title":"Generating data with a recursive CTE","text":"<p>The simplest example of a recursive CTE is one that generates a sequence of numbers. This is precisely what the example above does!</p> <p>There's two Excel equivalents to this:</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#there-are-two-excel-equivalents","title":"There are two Excel equivalents","text":"<ul> <li>The Series feature</li> <li>The <code>SEQUENCE</code> function</li> </ul> <p>The Series feature is in the Home tab, in the Editing group, and is called Series... (under AutoSum). This is not available in the Web version of Excel; Microsoft recommend dragging the fill handle instead.</p> <p>The <code>SEQUENCE</code> function is a function to do the same as the Series feature and the fill handle.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#breaking-down-the-data-generation-example","title":"Breaking down the data generation example","text":"<p>We've gone through how the query is written, but we haven't explained what it does.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-anchor-select-statement_1","title":"The anchor <code>SELECT</code> statement","text":"<p>The anchor <code>SELECT</code> statement is only run once, and it's the starting point for the CTE.</p> <p>In our example, the anchor <code>SELECT</code> statement is:</p> <pre><code>SELECT 1 AS Number\n</code></pre> Number 1 <p>This is the starting point for the recursive CTE and is the first row to be passed to the recursive <code>SELECT</code> statement.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-recursive-select-statement_1","title":"The recursive <code>SELECT</code> statement","text":"<p>The first time that the recursive <code>SELECT</code> statement is run, it'll use the row from the anchor <code>SELECT</code> statement as its input; the rest of the time, it'll use the rows from the previous iteration (this will be significant in the hierarchy flattening example).</p> <p>As a reminder, the recursive <code>SELECT</code> statement is:</p> <pre><code>SELECT Number + 1\nFROM Numbers\nWHERE Number &lt; 5\n</code></pre> <p>We start with a single row from the anchor statement, so the first iteration of the recursive statement takes the <code>1</code> (which is less than <code>5</code>) and adds <code>1</code> to it to get <code>2</code>, so after this iteration the CTE is:</p> Number 1 \u2190 anchor 2 \u2190 1st iteration <p>Now the recursive <code>SELECT</code> statement is run again, but this time it uses the row from the first iteration as its input. It takes the <code>2</code> (which is less than <code>5</code>) and adds <code>1</code> to it to get <code>3</code>, so after this iteration the CTE is:</p> Number 1 \u2190 anchor 2 \u2190 1st iteration 3 \u2190 2nd iteration <p>This process continues for a third iteration, using only the row from the previous iteration (the <code>3</code>):</p> Number 1 \u2190 anchor 2 \u2190 1st iteration 3 \u2190 2nd iteration 4 \u2190 3rd iteration <p>The process continues for a fourth iteration, using only the row from the previous iteration (the <code>4</code>):</p> Number 1 \u2190 anchor 2 \u2190 1st iteration 3 \u2190 2nd iteration 4 \u2190 3rd iteration 5 \u2190 4th iteration <p>Finally, when the process attempts to run a fifth iteration using <code>5</code>, the <code>WHERE</code> condition <code>Number &lt; 5</code> is no longer met. No rows are generated during this iteration, so the CTE stops running and the final result is:</p> Number 1 2 3 4 5"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#generating-a-date-range","title":"Generating a date range","text":"<p>The same principle can be applied to generate a date range. The following query generates a date range from <code>2023-01-01</code> to <code>2023-01-31</code>:</p> <pre><code>WITH Dates AS (\n        SELECT CAST('2023-01-01' AS DATE) AS Date\n    UNION ALL\n        SELECT DATEADD(DAY, 1, Date)\n        FROM Dates\n        WHERE Date &lt; '2023-01-31'\n)\n\nSELECT *\nFROM Dates\n;\n</code></pre> Date 2023-01-01 2023-01-02 2023-01-03 2023-01-04 2023-01-05 2023-01-06 2023-01-07 2023-01-08 2023-01-09 2023-01-10 2023-01-11 2023-01-12 2023-01-13 2023-01-14 2023-01-15 2023-01-16 2023-01-17 2023-01-18 2023-01-19 2023-01-20 2023-01-21 2023-01-22 2023-01-23 2023-01-24 2023-01-25 2023-01-26 2023-01-27 2023-01-28 2023-01-29 2023-01-30 2023-01-31 <p>Can you think of any other ranges that you'd want to generate?</p> <p>Tip</p> <p>If you're working with a good data set, you'll hopefully have a table of dates that you can use instead of generating them (often called a \"calendar table\" or a \"date dimension\").</p> <p>However, not all data sets will have this, so generating a date range on the fly can be super useful!</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#flattening-hierarchical-data-with-a-recursive-cte","title":"Flattening hierarchical data with a recursive CTE","text":"<p>Warning</p> <p>There is no Excel equivalent to this, so wrapping your head around this will probably be a bit more difficult than the data generation example.</p> <p>Flattening hierarchical data is the other main use of a recursive CTE.</p> <p>There are lots of examples of hierarchical data:</p> <ul> <li>An organisation's structure, where each employee has a manager and each manager has a manager</li> <li>A family tree, where each person has parents and each parent has parents</li> <li>A file system, where each file is in a folder and each folder is in a folder</li> </ul> <p>We'll focus on the first example: an organisation's structure.</p> <p>The AdventureWorks database doesn't have a table for an organisation's structure, so we'll use the following CTE (adapted from the Microsoft docs) to create a table of employees and their managers:</p> <pre><code>WITH Organisation AS (\n    SELECT *\n    FROM (VALUES\n        (1,   N'Ken S\u00e1nchez',    N'Chief Executive Officer',      NULL),\n        (273, N'Brian Welcker',  N'Vice President of Sales',      1),\n        (274, N'Stephen Jiang',  N'North American Sales Manager', 273),\n        (275, N'Michael Blythe', N'Sales Representative',         274),\n        (276, N'Linda Mitchell', N'Sales Representative',         274),\n        (285, N'Syed Abbas',     N'Pacific Sales Manager',        273),\n        (286, N'Lynn Tsoflias',  N'Sales Representative',         285),\n        (16,  N'David Bradley',  N'Marketing Manager',            273),\n        (23,  N'Mary Gibson',    N'Marketing Specialist',         16)\n    ) AS V(EmployeeID, Name, Title, ManagerID)\n)\n\nSELECT *\nFROM Organisation\n;\n</code></pre> EmployeeID Name Title ManagerID 1 Ken S\u00e1nchez Chief Executive Officer null 273 Brian Welcker Vice President of Sales 1 274 Stephen Jiang North American Sales Manager 273 275 Michael Blythe Sales Representative 274 276 Linda Mitchell Sales Representative 274 285 Syed Abbas Pacific Sales Manager 273 286 Lynn Tsoflias Sales Representative 285 16 David Bradley Marketing Manager 273 23 Mary Gibson Marketing Specialist 16 <p>This table has the employee ID and their manager's ID, so it would be quite easy to write a query to get the manager's name for each employee -- just do a self-join:</p> <pre><code>WITH Organisation AS (...)\n\nSELECT\n    Employee.EmployeeID,\n    Employee.Name,\n    Employee.ManagerID,\n    Manager.Name AS ManagerName\nFROM Organisation AS Employee\n    LEFT JOIN Organisation AS Manager\n        ON Employee.ManagerID = Manager.EmployeeID\n;\n</code></pre> EmployeeID Name ManagerID ManagerName 1 Ken S\u00e1nchez null null 273 Brian Welcker 1 Ken S\u00e1nchez 274 Stephen Jiang 273 Brian Welcker 275 Michael Blythe 274 Stephen Jiang 276 Linda Mitchell 274 Stephen Jiang 285 Syed Abbas 273 Brian Welcker 286 Lynn Tsoflias 285 Syed Abbas 16 David Bradley 273 Brian Welcker 23 Mary Gibson 16 David Bradley <p>What if we wanted to know the hierarchy level of each employee (with the CEO as <code>1</code>)?</p> <p>Well, we could try some subqueries and unions, but this would be a lot to write:</p> <pre><code>WITH Organisation AS (...),\n\nLevel1 AS (\n    SELECT\n        1 AS EmployeeLevel,\n        EmployeeID,\n        ManagerID,\n        Name\n    FROM Organisation\n    WHERE ManagerID IS NULL  /* The CEO */\n),\n\nLevel2 AS (\n    SELECT\n        2 AS EmployeeLevel,\n        EmployeeID,\n        ManagerID,\n        Name\n    FROM Organisation\n    WHERE ManagerID IN (\n        SELECT EmployeeID\n        FROM Level1\n    )\n),\n\nLevel3 AS (\n    SELECT\n        3 AS EmployeeLevel,\n        EmployeeID,\n        ManagerID,\n        Name\n    FROM Organisation\n    WHERE ManagerID IN (\n        SELECT EmployeeID\n        FROM Level2\n    )\n),\n\nLevel4 AS (\n    SELECT\n        4 AS EmployeeLevel,\n        EmployeeID,\n        ManagerID,\n        Name\n    FROM Organisation\n    WHERE ManagerID IN (\n        SELECT EmployeeID\n        FROM Level3\n    )\n)\n\n    SELECT * FROM Level1\nUNION\n    SELECT * FROM Level2\nUNION\n    SELECT * FROM Level3\nUNION\n    SELECT * FROM Level4\n;\n</code></pre> <p>Not only is this a lot to write, but it's also not very flexible. We needed to know how many levels there were in the hierarchy to write this query, and if the hierarchy changes, we'd need to change the query.</p> <p>This is where a recursive CTE comes in handy!</p> <p>The recursive CTE will keep going until it runs out of rows, so it doesn't need to know how many levels there are in the hierarchy beforehand.</p> <pre><code>WITH Organisation AS (...),\n\nLevels AS (\n        SELECT\n            1 AS EmployeeLevel,\n            EmployeeID,\n            ManagerID,\n            Name\n        FROM Organisation\n        WHERE ManagerID IS NULL  /* The CEO */\n    UNION ALL\n        SELECT\n            Levels.EmployeeLevel + 1,\n            Organisation.EmployeeID,\n            Organisation.ManagerID,\n            Organisation.Name\n        FROM Organisation\n            INNER JOIN Levels\n                ON Organisation.ManagerID = Levels.EmployeeID\n)\n\nSELECT *\nFROM Levels\n;\n</code></pre> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez 2 273 1 Brian Welcker 3 274 273 Stephen Jiang 3 285 273 Syed Abbas 3 16 273 David Bradley 4 23 16 Mary Gibson 4 286 285 Lynn Tsoflias 4 275 274 Michael Blythe 4 276 274 Linda Mitchell <p>This query is definitely shorter than the subquery/union version, but it's more complex than the data generation example; there are a few differences to call out and explain.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-anchor-select-statement_2","title":"The anchor <code>SELECT</code> statement","text":"<p>The anchor statement this time is:</p> <pre><code>SELECT\n    1 AS EmployeeLevel,\n    EmployeeID,\n    ManagerID,\n    Name\nFROM Organisation\nWHERE ManagerID IS NULL  /* The CEO */\n</code></pre> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez <p>In contrast to the data generation example, we want to start with an actual employee. In this case, we want to start at the top of the hierarchy (the CEO) which is why we:</p> <ul> <li>Select from the <code>Organisation</code> table/CTE</li> <li>Filter for the row where <code>ManagerID</code> is <code>NULL</code></li> </ul> <p>This <code>WHERE</code> clause is just to set up the anchor node; this clause is not used in the recursive <code>SELECT</code> statement.</p> <p>We do, however, set the starting point for the <code>EmployeeLevel</code> column to <code>1</code> in the anchor statement.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-recursive-select-statement_2","title":"The recursive <code>SELECT</code> statement","text":"<p>The recursive statement is:</p> <pre><code>SELECT\n    Levels.EmployeeLevel + 1,\n    Organisation.EmployeeID,\n    Organisation.ManagerID,\n    Organisation.Name\nFROM Organisation\n    INNER JOIN Levels\n        ON Organisation.ManagerID = Levels.EmployeeID\n</code></pre> <p>The <code>Levels.EmployeeLevel + 1</code> line should be fairly intuitive: it's just adding <code>1</code> to the <code>EmployeeLevel</code> column from the previous iteration, just like in the data generation example.</p> <p>The <code>INNER JOIN</code> clause is where the magic happens. This is actually doing two things for us:</p> <ol> <li>It's how we know which rows to use from the <code>Organisation</code> table/CTE for this iteration. This example also shows that the recursive CTE can be referenced in a <code>JOIN</code> clause instead of just in the <code>FROM</code> clause.</li> <li>By being an <code>INNER JOIN</code>, it's also the termination condition for the CTE! When there are no more rows to join, the CTE will stop running. This is why we don't need a <code>WHERE</code> clause in the recursive <code>SELECT</code> statement.</li> </ol>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#breaking-down-the-hierarchy-flattening-example","title":"Breaking down the hierarchy flattening example","text":"<p>This is still probably a bit confusing, so let's break it down with the first few iterations.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-anchor-is-the-ceo","title":"The anchor is the CEO","text":"<p>We've already seen that the anchor statement gives us the CEO:</p> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-first-iteration-is-the-ceos-direct-reports","title":"The first iteration is the CEO's direct report(s)","text":"<p>The first iteration of the recursive statement will use the CEO's <code>EmployeeID</code> to find the employees who report to the CEO, and it'll increment the <code>EmployeeLevel</code> by <code>1</code>:</p> EmployeeLevel EmployeeID ManagerID Name 2 273 1 Brian Welcker <p>At this point, the CTE will be:</p> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez \u2190 anchor 2 273 1 Brian Welcker \u2190 1st iteration"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-second-iteration-is-the-first-iterations-direct-reports","title":"The second iteration is the first iteration's direct report(s)","text":"<p>The second iteration will use the output of the first iteration, namely Brian Welcker, and find their direct reports (and increment the <code>EmployeeLevel</code> by <code>1</code>):</p> EmployeeLevel EmployeeID ManagerID Name 3 274 273 Stephen Jiang 3 285 273 Syed Abbas 3 16 273 David Bradley <p>At this point, the CTE will be:</p> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez \u2190 anchor 2 273 1 Brian Welcker \u2190 1st iteration 3 274 273 Stephen Jiang \u2190 2nd iteration 3 285 273 Syed Abbas \u2190 2nd iteration 3 16 273 David Bradley \u2190 2nd iteration <p>This is a case that we haven't seen yet: this iteration has produced multiple rows. This means that all three of these rows will be used in the next iteration.</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-third-iteration-is-the-second-iterations-direct-reports","title":"The third iteration is the second iteration's direct report(s)","text":"<p>The third iteration will use the output of the second iteration, namely Stephen Jiang, Syed Abbas, and David Bradley, and find their direct reports (and increment the <code>EmployeeLevel</code> by <code>1</code>):</p> EmployeeLevel EmployeeID ManagerID Name 4 23 16 Mary Gibson 4 286 285 Lynn Tsoflias 4 275 274 Michael Blythe 4 276 274 Linda Mitchell <p>At this point, the CTE will be:</p> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez \u2190 anchor 2 273 1 Brian Welcker \u2190 1st iteration 3 274 273 Stephen Jiang \u2190 2nd iteration 3 285 273 Syed Abbas \u2190 2nd iteration 3 16 273 David Bradley \u2190 2nd iteration 4 23 16 Mary Gibson \u2190 3rd iteration 4 286 285 Lynn Tsoflias \u2190 3rd iteration 4 275 274 Michael Blythe \u2190 3rd iteration 4 276 274 Linda Mitchell \u2190 3rd iteration"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#the-fourth-iteration-will-terminate-the-loop","title":"The fourth iteration will terminate the loop","text":"<p>When the fourth iteration is run, it will look for the direct reports of Mary Gibson, Lynn Tsoflias, Michael Blythe, and Linda Mitchell by using the <code>INNER JOIN</code>.</p> <p>Since there are no direct reports for these employees, the <code>INNER JOIN</code> will not produce any rows, and the CTE will stop running!</p> <p>Therefore, the final result is:</p> EmployeeLevel EmployeeID ManagerID Name 1 1 null Ken S\u00e1nchez 2 273 1 Brian Welcker 3 274 273 Stephen Jiang 3 285 273 Syed Abbas 3 16 273 David Bradley 4 23 16 Mary Gibson 4 286 285 Lynn Tsoflias 4 275 274 Michael Blythe 4 276 274 Linda Mitchell"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#other-hierarchy-flattening-examples","title":"Other hierarchy flattening examples","text":"<p>If you want to see some more hierarchy flattening examples, check out the Microsoft documentation's examples (it has some good ones!):</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#use-a-recursive-common-table-expression-to-display-two-levels-of-recursion</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#use-a-recursive-common-table-expression-to-display-a-hierarchical-list</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#e-use-a-common-table-expression-to-selectively-step-through-a-recursive-relationship-in-a-select-statement</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#h-use-multiple-anchor-and-recursive-members</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#bkmkUsingAnalyticalFunctionsInARecursiveCTE</li> </ul> <p>Tip</p> <p>You might be thinking: what if the recursive CTE never hits the termination condition?</p> <p>Microsoft SQL Server will stop the CTE after 100 iterations, so you won't get an infinite loop.</p> <p>You might then be thinking: what if I want more than 100 iterations?</p> <p>Microsoft SQL Server allows you to change this with the <code>MAXRECURSION</code> option:</p> <pre><code>WITH SomeRecursiveCTE AS (...)\n\nSELECT *\nFROM SomeRecursiveCTE\nOPTION (MAXRECURSION 500)\n;\n</code></pre>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#a-quick-note-for-the-programmers","title":"A quick note for the programmers","text":"<p>Warning</p> <p>If you've never done any programming before, skip this bit!</p> <p>If you've used other programming languages, you might be thinking that recursive CTEs are similar to loops. You'd be right!</p> <p>Just like how correlated subqueries can be thought of as for-loops, recursive CTEs can be thought of as while-loops that run while a condition is met.</p> <p>This is why recursive CTEs can be slow if used inappropriately: they can run a lot of times!</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#some-fun-recursive-cte-examples","title":"Some fun recursive CTE examples","text":"<p>Warning</p> <p>These are just for fun. If you're not comfortable with the main concepts, don't worry about these examples!</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#generating-a-fibonacci-sequence","title":"Generating a Fibonacci sequence","text":"<p>The Fibonacci sequence is a sequence of numbers where each number is the sum of the two preceding ones. For example, the first few terms are:</p> <ul> <li>1</li> <li>1</li> <li>2 (1 + 1)</li> <li>3 (1 + 2)</li> <li>5 (2 + 3)</li> <li>8 (3 + 5)</li> <li>...</li> </ul> <p>To generate the first <code>10</code> terms of the Fibonacci sequence, you can use the following recursive CTE:</p> <pre><code>WITH Fibonacci AS (\n        SELECT\n            1 AS n,\n            1 AS f_n,  /* f(n) */\n            0 AS f_n_1   /* f(n - 1) */\n    UNION ALL\n        SELECT\n            n + 1 AS n,\n            f_n + f_n_1 AS f_n,\n            f_n AS f_n_1\n        FROM Fibonacci\n        WHERE n &lt; 10\n)\n\nSELECT\n    n,\n    f_n\nFROM Fibonacci\n</code></pre> n f_n 1 1 2 1 3 2 4 3 5 5 6 8 7 13 8 21 9 34 10 55"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#generating-the-mandelbrot-set","title":"Generating the Mandelbrot set","text":"<p>Info</p> <p>This example is taken from Graeme Job at:</p> <ul> <li>https://thedailywtf.com/articles/Stupid-Coding-Tricks-The-TSQL-Madlebrot</li> </ul> <p>The following beauty produces the Mandelbrot set, a well-known fractal, and the SQL is written by Graeme Job:</p> <pre><code>WITH\n    XGEN(X, IX) AS (\n        /* X DIM GENERATOR */\n            SELECT\n                CAST(-2.2 AS FLOAT) AS X,\n                0 AS IX\n        UNION ALL\n            SELECT\n                CAST(X + 0.031 AS FLOAT) AS X,\n                IX + 1 AS IX\n            FROM XGEN\n            WHERE IX &lt; 100\n    ),\n    YGEN(Y, IY) AS (\n        /* Y DIM GENERATOR */\n            SELECT\n                CAST(-1.5 AS FLOAT) AS Y,\n                0 AS IY\n        UNION ALL\n            SELECT\n                CAST(Y + 0.031 AS FLOAT) AS Y,\n                IY + 1 AS IY\n            FROM YGEN\n            WHERE IY &lt; 100\n    ),\n    Z(IX, IY, CX, CY, X, Y, I) AS (\n        /* Z POINT ITERATOR */\n            SELECT\n                IX,\n                IY,\n                X AS CX,\n                Y AS CY,\n                X,\n                Y,\n                0 AS I\n            FROM XGEN, YGEN\n        UNION ALL\n            SELECT\n                IX,\n                IY,\n                CX,\n                CY,\n                X * X - Y * Y + CX AS X,\n                Y * X * 2 + CY,\n                I + 1\n            FROM Z\n            WHERE X * X + Y * Y &lt; 16\n              AND I &lt; 100\n    )\n\nSELECT\n    TRANSLATE(\n        (\n            X0 +X1 +X2 +X3 +X4 +X5 +X6 +X7 +X8 +X9 +X10+X11+X12+X13+X14+X15+X16+X17+X18+X19+\n            X20+X21+X22+X23+X24+X25+X26+X27+X28+X29+X30+X31+X32+X33+X34+X35+X36+X37+X38+X39+\n            X40+X41+X42+X43+X44+X45+X46+X47+X48+X49+X50+X51+X52+X53+X54+X55+X56+X57+X58+X59+\n            X60+X61+X62+X63+X64+X65+X66+X67+X68+X69+X70+X71+X72+X73+X74+X75+X76+X77+X78+X79+\n            X80+X81+X82+X83+X84+X85+X86+X87+X88+X89+X90+X91+X92+X93+X94+X95+X96+X97+X98+X99\n        ),\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n        ' .,,,-----++++%%%%@@@@### '\n    )\nFROM (\n    SELECT\n        'X' + CAST(IX AS VARCHAR) AS IX,\n        IY,\n        SUBSTRING('ABCDEFGHIJKLMNOPQRSTUVWXYZ', ISNULL(NULLIF(I, 0), 1), 1) AS I\n    FROM Z\n) AS ZT\nPIVOT (\n    MAX(I) FOR IX IN (\n        X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10,X11,X12,X13,X14,X15,X16,X17,X18,X19,\n        X20,X21,X22,X23,X24,X25,X26,X27,X28,X29,X30,X31,X32,X33,X34,X35,X36,X37,X38,X39,\n        X40,X41,X42,X43,X44,X45,X46,X47,X48,X49,X50,X51,X52,X53,X54,X55,X56,X57,X58,X59,\n        X60,X61,X62,X63,X64,X65,X66,X67,X68,X69,X70,X71,X72,X73,X74,X75,X76,X77,X78,X79,\n        X80,X81,X82,X83,X84,X85,X86,X87,X88,X89,X90,X91,X92,X93,X94,X95,X96,X97,X98,X99\n    )\n) AS PZT\n;\n</code></pre> <p>The output doesn't look great here, so give it a run yourself!</p>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on recursive CTEs at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/with-common-table-expression-transact-sql#guidelines-for-defining-and-using-recursive-common-table-expressions</li> </ul>"},{"location":"from-excel-to-sql/advanced-concepts/recursive-ctes/#some-links-for-excel-stuff","title":"Some links for Excel stuff","text":"<p>The Series feature and the fill handles are documented at:</p> <ul> <li>https://support.microsoft.com/en-gb/office/project-values-in-a-series-5311f5cf-149e-4d06-81dd-5aaad87e5400</li> <li>https://support.microsoft.com/en-gb/office/fill-data-automatically-in-worksheet-cells-74e31bdd-d993-45da-aa82-35a236c5b5db</li> </ul> <p>The <code>SEQUENCE</code> function can be super handy for generating sequences of numbers in Excel. The official documentation is at:</p> <ul> <li>https://support.microsoft.com/en-gb/office/sequence-function-57467a98-57e0-4817-9f14-2eb78519ca90</li> </ul> <p>However, the following tutorials are also super useful:</p> <ul> <li>https://exceljet.net/functions/sequence-function</li> <li>https://exceljet.net/videos/the-sequence-function</li> <li>https://exceljet.net/formulas/sequence-of-days</li> <li>https://exceljet.net/formulas/sequence-of-times</li> <li>https://exceljet.net/formulas/sequence-of-months</li> <li>https://exceljet.net/formulas/sequence-of-years</li> </ul>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/","title":"Setting the context \ud83e\udd14","text":""},{"location":"from-excel-to-sql/getting-started/setting-the-context/#what-the-fudge-is-sql","title":"What the fudge is SQL?","text":"<p>Success</p> <p>SQL stands for Structured Query Language.</p> <p>SQL is a programming language oriented around data. The confusing part about SQL is that it isn't one language: there are loads of different \"flavours\" of SQL!</p>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/#spreadsheets-and-sql","title":"Spreadsheets and SQL","text":"<p>To help make this a bit more relatable, think about the general concept of a \"spreadsheet\".</p> <p>This is a general concept because there are lots of different \"implementations\" of spreadsheet software, for example:</p> <ul> <li>Microsoft Excel</li> <li>Google Sheets</li> <li>Apple Numbers</li> <li>LibreOffice</li> </ul> <p>SQL is also a general concept; there are loads of different \"implementations\" of SQL, for example:</p> <ul> <li>Microsoft SQL Server</li> <li>Google BigQuery</li> <li>PostgreSQL</li> <li>MySQL</li> </ul> <p>Tip</p> <p>If someone claims that they're a \"SQL wiz\", always ask them \"which flavour?\" \ud83d\ude1d</p>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/#what-does-sql-do","title":"What does SQL do?","text":"<p>The point of SQL is to interact with data that lives in a \"database\".</p> <p>Since SQL is a programming language, you write some code, then you run it. Running SQL code means running it on this \"database\", and we usually call the SQL code a \"query\".</p> <p>The reason that we have so many different flavours of SQL is because each one is specific to the database that it's running on.</p> <p>If you want to write SQL on your own machine, you'll need to install a database. This is just like needing to install a spreadsheet application (e.g. Excel) to work with spreadsheets \ud83d\ude0b</p>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/#what-the-fudge-is-a-database","title":"What the fudge is a database?","text":"<p>Success</p> <p>A database is just some software that stores and manipulates data.</p> <p>There are a few different types of databases, but SQL is designed for databases that store their data as tables. This makes these types of databases very familiar to us: they're like spreadsheets!</p>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/#database-tables-are-like-excel-tables","title":"Database tables are like Excel tables","text":"<p>One of the awesome things about spreadsheets is that the sheets are super flexible, and you can have data pretty much wherever you want.</p> <p>Databases are a bit more rigid. The tables in databases are like the tables in spreadsheets, with a few key differences -- the most important differences to know are:</p> <ul> <li>Database tables cannot have merged cells</li> <li>Columns in database tables have a specific data type (more on this later)</li> </ul> <p>Database tables are very similar to the table structures in Excel that you create with the \"Format as Table\" feature:</p> <ul> <li>https://support.microsoft.com/en-gb/office/bf0ce08b-d012-42ec-8ecf-a2259c9faf3f</li> </ul> <p>It'll be important to understand these Excel \"tables\" as we go through this course, so if you're not familiar with them, it's worth checking out the link above or the one below:</p> <ul> <li>https://exceljet.net/articles/excel-tables</li> </ul>"},{"location":"from-excel-to-sql/getting-started/setting-the-context/#why-the-fudge-should-you-use-sql","title":"Why the fudge should you use SQL?","text":"<p>Success</p> <p>SQL is everywhere!</p> <p>If you're looking to move into a more data-oriented role (e.g. data analyst, data scientist, data engineer, analytics engineer), SQL is a must-have skill.</p> <p>Even if you're just looking to find ways to improve your existing role, knowing SQL can empower you to crunch more data, streamline/automate more processes, and generally make your life easier.</p>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/","title":"SQL syntax \ud83d\udcda","text":"<p>Success</p> <p>Syntax is the set of rules that define how you write in a programming language.</p> <p>SQL has a very flexible syntax which is heavily based on the English language. This makes it easy to read and write, but it also means that there are many ways to write the same thing.</p> <p>We'll go through a lot of the specifics in the following sections, but here are some general rules to get you started.</p>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/#sql-sounds-like-english","title":"SQL \"sounds like\" English","text":"<p>Info</p> <p>At least, for simple queries \ud83d\ude1d</p> <p>Consider the following SQL statement (we'll go through what this means in the next sections):</p> <pre><code>SELECT first_name, last_name\nFROM employees\nWHERE department = 'Sales'\n</code></pre> <p>This reads closely to the English sentence:</p> <p>\"Select the first name and last name from the employees where the department is Sales\"</p> <p>The only words that we've dropped from the English version of the sentence are \"the\" and \"and\"!</p> <p>This is a basic example, but it's a good way to think about writing SQL when you're starting out. If it sounds like English, you're probably on the right track.</p>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/#whitespace-and-capitalisation-are-mostly-ignored","title":"Whitespace and capitalisation are (mostly) ignored","text":"<p>Note</p> <p>Some databases (\"SQL flavours\") are stricter about this than others, but most of the time they won't care about how you add whitespace or capitalise your letters.</p> <p>For the most part, SQL doesn't care about whitespace (spaces, tabs, new lines) or capitalisation. This means that all the following are equivalent:</p> <pre><code>SELECT first_name, last_name\nFROM employees\nWHERE department = 'Sales'\n</code></pre> <pre><code>select first_name, last_name from employees where department = 'Sales'\n</code></pre> <pre><code>SELECT\nFIRST_NAME,\nLAST_NAME\nFROM\nEMPLOYEES\nWHERE\nDEPARTMENT\n=\n'Sales'\n</code></pre> <pre><code>                             SeLeCt FiRsT_NaMe\n,\n                lAsT_nAmE\n    FrOm\n\n         eMpLoyEEs WhErE\n                 dEpaRTmEnT\n\n=\n                                    'Sales'\n</code></pre> <p>Of course, some of these are easier to read than others, so it's generally a good idea to use whitespace and capitalisation to make your SQL easier to read. Some choices are totally down to your opinion, we'll go through some best practices in the style guide section to help you choose a style that you like.</p>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/#semicolons-are-mostly-optional","title":"Semicolons are (mostly) optional","text":"<p>Note</p> <p>Semicolons are generally only required when you have multiple SQL statements in the same file (or when you're using a database/SQL flavour that requires them).</p> <p>Semicolons (<code>;</code>) are used to explicitly end a SQL statement. This is useful when you have multiple SQL statements in the same file, but it's not always required.</p> <p>Ending your SQL with a semicolon is a good habit to get into, but it's unlikely to be mandatory for the SQL that you write.</p> <pre><code>SELECT first_name, last_name\nFROM employees\nWHERE department = 'Sales'\n;\n</code></pre>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/#text-needs-to-be-put-in-single-quotes","title":"Text needs to be put in single quotes","text":"<p>Just like in Excel, any text needs to be enclosed in quotes in SQL. The only difference is that the quotes that you use are single quotes, <code>'</code>, not double quotes, <code>\"</code>.</p> <p>The quotes are used to tell the database that the text is text, and not a column name or a keyword.</p> <p>SQL also treats dates differently to Excel; we \"pretend\" that dates are some text and put them in single quotes. In general, dates need to be specified in the universal date format, <code>YYYY-MM-DD</code>.</p> <ul> <li><code>123</code> is an example of a number in SQL</li> <li><code>'abc'</code> is an example of text in SQL</li> <li><code>'2020-01-01'</code> is an example of a date in SQL</li> </ul>"},{"location":"from-excel-to-sql/getting-started/sql-syntax/#we-use-some-specific-words-to-describe-sql-elements","title":"We use some specific words to describe SQL elements","text":"<p>It's worth mentioning some of the specific words that we use to describe the elements of SQL. We'll use the example above to explain these terms, plus some other bits that we'll see later:</p> <ul> <li>Keywords are the words that are specific to SQL and have a special meaning. For example, the following are all keywords:<ul> <li><code>SELECT</code></li> <li><code>FROM</code></li> <li><code>WHERE</code></li> <li><code>AND</code></li> <li><code>OR</code></li> <li><code>ON</code></li> </ul> </li> <li>Identifiers are the names of the tables, columns, and other objects in your database. For example, the following are all identifiers:<ul> <li><code>employees</code></li> <li><code>first_name</code></li> <li><code>last_name</code></li> <li><code>department</code></li> </ul> </li> <li>Operators are the symbols that you use to compare or manipulate data. For example, the following are all operators:<ul> <li><code>+</code></li> <li><code>-</code></li> <li><code>=</code></li> <li><code>&gt;</code></li> <li><code>&lt;</code></li> </ul> </li> <li>Clauses are the different parts of an SQL statement made up of keywords, identifiers, and any other text. For example, the following are all clauses:<ul> <li><code>SELECT first_name, last_name</code></li> <li><code>FROM employees</code></li> <li><code>WHERE department = 'Sales'</code></li> </ul> </li> <li>Statements or queries are the complete SQL commands that you write. For example, the following is a statement/query:<ul> <li><code>SELECT first_name, last_name FROM employees WHERE department = 'Sales'</code></li> </ul> </li> <li>Result or result set is the data that comes back from the database when you run a query (more on this in the next section). For example, the following is a result set:</li> </ul> first_name last_name department John Smith Sales Jane Doe Sales"},{"location":"from-excel-to-sql/main-concepts/comments/","title":"Comments \ud83d\udcdd","text":"<p>Success</p> <p>Comments are a way to add notes to your SQL code. They are not executed and are only there for the benefit of the reader.</p> <p>Note</p> <p>Comments can go anywhere in your SQL code! \ud83d\ude80</p>"},{"location":"from-excel-to-sql/main-concepts/comments/#comments-can-be-written-with-or","title":"Comments can be written with <code>--</code> or <code>/* */</code>","text":"<p>A \"comment\" in an SQL statement is some text which is ignored when the query is run. It's a way to add notes to your code to help explain what's happening.</p> <p>There are two ways to write comments in SQL:</p> <ol> <li>Single-line comments using <code>--</code> which comment out the rest of the line</li> <li>Multi-line comments using <code>/* */</code> which comment out everything they enclose</li> </ol> <p>For info, the multi-line comment goes by several different names:</p> <ul> <li>\"C-style\" comment</li> <li>\"Block\" comment</li> <li>\"Slash-star\" comment</li> </ul> <p>Writing comments is super easy, for example:</p> <pre><code>-- This is a title\nSELECT *\nFROM HumanResources.Department\n;\n\n/*\nThis query won't run\n\nSELECT *\nFROM HumanResources.Department\n;\n*/\n</code></pre> <p>Warning</p> <p>Comments can be helpful for explaining bits of code, but a comment should never excuse bad code! Use them sparingly and only when necessary.</p> <p>Tip</p> <p>This is my personal preference, but I'd recommend using the slash-star comments for any \"documentation\", and the double-dash comments for any (temporary) commented-out code. This is because the double-dash comments are the ones used by most IDEs to \"comment out\" code, so following this practice makes it easier to distinguish between the two types of comments.</p>"},{"location":"from-excel-to-sql/main-concepts/comments/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on comments at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/comment-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/slash-star-comment-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/H6SfeXFWWmg</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/conditionals/","title":"Conditionals \ud83d\udd00","text":"<p>Success</p> <p>Just like Excel's <code>IF</code> function, SQL has a few ways to handle conditional logic.</p>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#sqls-if-function-is-iif","title":"SQL's \"if\" function is <code>IIF</code>","text":"<p>Info</p> <p>Why is it called <code>IIF</code>? It's short for \"Immediate If\" which is the typical name programming languages give a function that acts like the <code>IF</code> function in Excel. This is to distinguish the <code>IIF</code> function from the alternative <code>IF</code> statement already in the programming language, and SQL is no exception.</p> <p>This is just an FYI. If it doesn't make sense, don't worry about it! \ud83d\ude1d</p> <p>The <code>IIF</code> function is exactly what you'd expect: it's the same as the Excel <code>IF</code> function!</p> <pre><code>SELECT IIF(AGE &lt; 18, 'Child', 'Adult') AS AGE_GROUP\n</code></pre> <p>This function is great for simple conditions, but anyone who's used Excel for a while knows that anything slightly more complex can get a bit unwieldy.</p> <p>To handle more complex conditions, SQL has a <code>CASE</code> statement.</p>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#case-statements-are-great-for-complex-conditions","title":"<code>CASE</code> statements are great for complex conditions","text":"<p>Note</p> <p>The <code>CASE</code> statement is a staple of SQL and is used in many different SQL dialects. It's worth getting to know it well!</p> <p>A <code>CASE</code> statement is really a series of <code>IF</code> statements (logically).</p> <p>Converting the <code>IIF</code> example from above to a <code>CASE</code> statement looks like this:</p> <pre><code>SELECT\n    CASE\n        WHEN AGE &lt; 18\n            THEN 'Child'\n            ELSE 'Adult'\n    END AS AGE_GROUP\n</code></pre> <p>When a <code>CASE</code> statement is used, the <code>WHEN</code> part is checked for each value. For each value, if a condition is met the <code>THEN</code> part is used, otherwise the next condition is checked.</p> <p>To show this off, the example above can be extended to include more conditions:</p> <pre><code>SELECT\n    CASE\n        WHEN AGE &lt; 13\n            THEN 'Child'\n        WHEN AGE &lt; 18\n            THEN 'Teenager'\n            ELSE 'Adult'\n    END AS AGE_GROUP\n</code></pre> <p>Info</p> <p>The corresponding Excel formula for this <code>CASE</code> statement would be (assuming the age is in cell <code>A1</code>):</p> <pre><code>=IF(A1 &lt; 13, \"Child\", IF(A1 &lt; 18, \"Teenager\", \"Adult\"))\n</code></pre> <p>Let's walk through this example to see how it works. Suppose that the underlying data has the following rows:</p> ID AGE 1 10 2 15 3 23 4 18 5 null <ol> <li>The first row has an age of 10, so the first condition, <code>AGE &lt; 13</code>, is met and therefore the result is <code>Child</code>.</li> <li>The second row has an age of 15, so the first condition is not met. This means that the second condition, <code>AGE &lt; 18</code>, is checked. The second condition is met so the result is <code>Teenager</code>.</li> <li>The third row has an age of 23, so neither the first condition nor the second condition are met. There are no more conditions so the <code>ELSE</code> part is used and the result is <code>Adult</code>.</li> <li>The fourth row has an age of 18, so the first condition is not met. The second condition is also not met because 18 is not less than 18, so the result for this row is also <code>Adult</code>.</li> <li>The fifth row is missing an age, so SQL can't say whether the conditions (<code>AGE &lt; 13</code> and <code>AGE &lt; 18</code>) are met. Therefore, it assumes that they're not met and also uses the else part of the <code>CASE</code> statement, also resulting in <code>Adult</code>.</li> </ol> ID AGE AGE_GROUP 1 10 Child 2 15 Teenager 3 23 Adult 4 18 Adult 5 null Adult <p>Warning</p> <p>The last example (with the missing age) might be a bit confusing, so it's important to practice using data with <code>NULL</code> values to get used to handling them.</p> <p>Tip</p> <p>When using case statements, it is usually a good idea to have a condition that checks for <code>NULL</code> values right at the start. Adding this to the example above might look something like:</p> <pre><code>SELECT\n   CASE\n       WHEN AGE IS NULL\n           THEN 'Unknown'\n       WHEN AGE &lt; 13\n           THEN 'Child'\n       WHEN AGE &lt; 18\n           THEN 'Teenager'\n           ELSE 'Adult'\n   END AS AGE_GROUP\n</code></pre> <p>The corresponding Excel formula for this <code>CASE</code> statement would be (assuming the age is in cell <code>A1</code>) something like:</p> <pre><code>=IF(A1 = \"\", \"Unknown\", IF(A1 &lt; 13, \"Child\", IF(A1 &lt; 18, \"Teenager\", \"Adult\")))\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#keep-redundant-logic-out-of-your-case-statements","title":"Keep redundant logic out of your <code>CASE</code> statements","text":"<p>Notice how the order of the conditions in the <code>CASE</code> statement is important. Since the <code>AGE &lt; 18</code> condition comes after the <code>AGE &lt; 13</code> condition, the <code>AGE &lt; 18</code> condition already knows that the age is at least 13 if a value comes to it! If it wasn't, it would have been caught by the <code>AGE &lt; 13</code> condition.</p> <p>Out in the wild, you might find people who still add these redundant conditions to their <code>CASE</code> statements. It's not wrong to do this, but it's not necessary and it can make the code harder to read.</p> <p>For example, the following <code>CASE</code> statement is equivalent to the one above, but it includes the redundant conditions which make it harder to read:</p> <pre><code>SELECT\n    CASE\n        WHEN AGE IS NULL\n            THEN 'Unknown'\n        WHEN AGE IS NOT NULL AND AGE &lt; 13  /* `AGE IS NOT NULL` is redundant! */\n            THEN 'Child'\n        WHEN AGE IS NOT NULL AND AGE &gt;= 13 AND AGE &lt; 18  /* `AGE IS NOT NULL AND AGE &gt;= 13` is redundant! */\n            THEN 'Teenager'\n            ELSE 'Adult'\n    END AS AGE_GROUP\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#alternative-case-syntax","title":"Alternative <code>CASE</code> syntax","text":"<p>There are times when you might want to use the <code>CASE</code> statement to convert one set of values into another set of values, for example:</p> <pre><code>SELECT\n    CASE\n        WHEN CODE = 'A'\n            THEN 'Alpha'\n        WHEN CODE = 'B'\n            THEN 'Bravo'\n        WHEN CODE = 'C'\n            THEN 'Charlie'\n            ELSE 'Unknown'\n    END AS PHONETIC\n</code></pre> <p>In this specific case where the conditions are all checking for specific values (using an equals) in a single column, the column can be specified once at the start of the <code>CASE</code> statement and just the values can be written in the <code>WHEN</code> part:</p> <pre><code>SELECT\n    CASE CODE\n        WHEN 'A'\n            THEN 'Alpha'\n        WHEN 'B'\n            THEN 'Bravo'\n        WHEN 'C'\n            THEN 'Charlie'\n            ELSE 'Unknown'\n    END AS PHONETIC\n</code></pre> CODE PHONETIC A Alpha B Bravo C Charlie D Unknown null Unknown <p>Tip</p> <p>Mapping values like this is convenient with the <code>CASE</code> statement, but in most cases it's better to have a lookup table that you can join on (we'll cover joins later).</p> <p>However, you might not always have a lookup table available, so the <code>CASE</code> statement is a good alternative in those cases.</p>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#the-sql-for-running-these-examples","title":"The SQL for running these examples","text":"<p>Danger</p> <p>The data for these examples isn't in the AdventureWorks database that we're using, so it has been created for this section. If you want to run these examples yourself, you can use the SQL below but note that this is using some features that we haven't covered yet!</p> <p>For the examples above, the rows are created on the fly. You're not expected to understand this yet, but it's provided so that you can run the SQL yourself if you want to.</p> <pre><code>/* Age Example */\nSELECT\n    ID,\n    AGE,\n    CASE\n        WHEN AGE IS NULL\n            THEN 'Unknown'\n        WHEN AGE &lt; 13\n            THEN 'Child'\n        WHEN AGE &lt; 18\n            THEN 'Teenager'\n            ELSE 'Adult'\n    END AS AGE_GROUP\nFROM (\n    VALUES\n        (1, 10),\n        (2, 15),\n        (3, 23),\n        (4, 18),\n        (5, NULL)\n) AS AGES(ID, AGE)\n;\n\n/* Phonetic Example */\nSELECT\n    CODE,\n    CASE CODE\n        WHEN 'A'\n            THEN 'Alpha'\n        WHEN 'B'\n            THEN 'Bravo'\n        WHEN 'C'\n            THEN 'Charlie'\n            ELSE 'Unknown'\n    END AS PHONETIC\nFROM (\n    VALUES\n        ('A'),\n        ('B'),\n        ('C'),\n        ('D'),\n        (NULL)\n) AS CODES(CODE)\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/conditionals/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on <code>IIF</code> and <code>CASE</code> at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/logical-functions-iif-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/case-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/4admV4I3fMU</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/data-types/","title":"Data types \ud83e\uddf1","text":"<p>Success</p> <p>Understanding data types is a fundamental part of working with SQL.</p> <p>Warning</p> <p>This is one of the biggest differences between Excel and SQL. In Excel, you can just type whatever you want into a cell, and it will be interpreted as a number, a date, or some text appropriately.</p> <p>In SQL, each column will have an explicit type of data that it can hold.</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#there-are-lots-of-data-types","title":"There are lots of data types","text":"<p>When we work with Excel, we really only think about two (maybe three) types of data:</p> <ul> <li>Numbers</li> <li>Text</li> <li>Dates (but these are really numbers, anyway)</li> </ul> <p>In SQL database, there are loads of different data types!</p> <p>Even something like numbers has several different data types, each covering a different range of numbers and whether to care about decimal places.</p> <p>This might feel like a pain, but SQL databases are able to do some things so well precisely because we have to be explicit about the data types. We won't go into why in this course, but just know that it's a good thing!</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#microsoft-sql-server-data-types","title":"Microsoft SQL Server data types","text":"<p>Warning</p> <p>You are not expected to understand this straight away. This is just to give you an idea of the variety of data types that are available.</p> <p>The data types that Microsoft SQL Server has (be default) are all documented at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql</li> </ul> <p>We'll just call out a few of the most common ones here so that you can get a feel for what's available and start to recognise them.</p> Data type Description <code>INT</code> Whole numbers (no decimal places) in the range -2,147,483,648 to 2,147,483,647 (-2<sup>31</sup> to 2<sup>31</sup> - 1) <code>DECIMAL</code>* Numbers with decimal places. When maximum precision is used, valid values are from -10<sup>38</sup> + 1 through 10<sup>38</sup> - 1. <code>VARCHAR</code>* Variable-length string of text. Maximum length is specified. <code>NVARCHAR</code>* Variable-length string of text that allows unicode characters. Maximum length is specified. <code>DATE</code> Date values in the range 0001-01-01 through 9999-12-31. <code>TIME</code> Time values in the range 00:00:00.0000000 through 23:59:59.9999999. <code>DATETIME</code> Date and time values in the range 1753-01-01 through 9999-12-31. <p>Note</p> <p>The data types denoted with the <code>*</code> also require specifying a precision and scale (if they're a type of number) or a length (if they're a type of text).</p> <p>For example:</p> <ul> <li><code>DECIMAL(10, 2)</code> would be a number with 10 total digits and 2 decimal places (so 8 digits before the decimal place).</li> <li><code>VARCHAR(50)</code> would be a string of text with a maximum length of 50 characters.</li> </ul> <p>If you're not sure what data type the column you're working with is, you can check the <code>INFORMATION_SCHEMA.COLUMNS</code> table to see the data types of the columns in a table. For example, the query below shows the data types of the columns in the <code>HumanResources.Department</code> table:</p> <pre><code>SELECT COLUMN_NAME, DATA_TYPE\nFROM INFORMATION_SCHEMA.COLUMNS\nWHERE TABLE_SCHEMA = 'HumanResources'\n  AND TABLE_NAME = 'Department'\n;\n</code></pre> COLUMN_NAME DATA_TYPE DepartmentID smallint Name nvarchar GroupName nvarchar ModifiedDate datetime"},{"location":"from-excel-to-sql/main-concepts/data-types/#use-the-cast-function-to-change-data-types","title":"Use the <code>CAST</code> function to change data types","text":"<p>Now that we know what data types are available, we want to know how to change the data type of a column \ud83d\ude04</p> <p>It's worth noting that SQL will regularly do behind-the-scenes conversions of data types for you, but it's good to be explicit about what you're doing.</p> <p>When you want (or need) to be explicit about the data type of a column, use the <code>CAST</code> function:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql</li> </ul> <p>This function looks a bit different to the functions that we'll have seen so far or in Excel. To use it, we write the column that we want to change the data type of, then the <code>AS</code> keyword, then the new data type that we want to change it to.</p> <p>For example, if we want to change the <code>DepartmentID</code> column to text or to a number with decimal places, we could use the following query:</p> <pre><code>SELECT TOP 5\n    DepartmentID,\n    CAST(DepartmentID AS VARCHAR(10)) AS DepartmentID_VARCHAR,\n    CAST(DepartmentID AS DECIMAL(8, 2)) AS DepartmentID_DECIMAL\nFROM HumanResources.Department\n;\n</code></pre> DepartmentID DepartmentID_VARCHAR DepartmentID_DECIMAL 12 12 12.00 1 1 1.00 16 16 16.00 14 14 14.00 10 10 10.00 <p>The text version looks the same, but I can guarantee that it's not a number any more! \ud83d\ude1d</p> <p>Note</p> <p>After using Excel for so long, this might feel a bit weird -- but Excel will sometimes hold numbers as text, and it's not always obvious when it's doing that.</p> <p>You can store a number as text yourself in Excel in loads of ways, for example using <code>=\"123\"</code>, <code>='123</code>, or just typing <code>123</code> into a cell that's formatted as text.</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#what-about-casting-something-that-cant-be-converted","title":"What about casting something that can't be converted?","text":"<p>If you try to cast a value to a data type that it can't be converted to, you'll get an error.</p> <p>For example, the following will break:</p> <pre><code>SELECT CAST('abc' AS INT)\n;\n</code></pre> <p>SQL doesn't know how to convert the text <code>'abc'</code> into a number, so it will complain!</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#null-is-a-special-value-that-can-be-used-in-any-data-type","title":"<code>NULL</code> is a special value that can be used in any data type","text":"<p>Warning</p> <p><code>NULL</code> values can be a pain to work with, but they're a fundamental part of SQL. It's worth getting to grips with them early on.</p> <p><code>NULL</code> is a special value that can be used in any data type. It's used to represent the absence of a value, and it's different to <code>0</code>, <code>''</code>, or any other value that you might use to represent \"nothing\".</p> <p>Excel has a similar concept, but it's not as explicit as it is in SQL. In Excel, your cells can be empty, and this is similar to <code>NULL</code> in SQL. An empty cell is not the same as a cell with a value of <code>0</code> or <code>\"\"</code>!</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#whats-this-mysterious","title":"What's this mysterious <code>''</code>/<code>\"\"</code>?","text":"<p>This is known as the \"empty string\", and Excel has it too -- <code>''</code> is the SQL version and <code>\"\"</code> is the Excel version.</p> <p>It's a piece of text that has no characters in it. \ud83d\ude04</p> <p>It's not the same as <code>NULL</code>, but it's also not the same as a string of text with a space in it!</p> <p>Warning</p> <p>If you've not seen this before, don't worry too much about it. It's just something to be aware of.</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#null-vs-vs-0","title":"<code>NULL</code> vs <code>''</code> vs <code>0</code>","text":"<p>The concept of a <code>NULL</code> value doesn't exist only in SQL, so when people start to learn about it for the first time, you'll usually see an image like the one below shown to help explain it:</p> <p></p> <p>Humour aside, it's a good way to think about it. <code>NULL</code> is not the same as <code>''</code> or <code>0</code>; rather than saying that something is \"empty\" or \"zero\", it's saying that there's no value there at all.</p>"},{"location":"from-excel-to-sql/main-concepts/data-types/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on data types at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql</li> </ul> <p>The docs for <code>NULL</code> are at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/null-and-unknown-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/Vp40VH4_OX8</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/","title":"Date formatting \ud83d\udcc6","text":"<p>Success</p> <p>Formatting dates in SQL is very similar to formatting dates in Excel -- the <code>FORMAT</code> function is SQL's equivalent of the <code>TEXT</code> function in Excel.</p> <p>Info</p> <p>I'm from the UK so I've used UK date formats in the examples, but you can find US date formats in the Microsoft SQL Server documentation.</p>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#formatting-dates-in-excel","title":"Formatting dates in Excel","text":"<p>You may have noticed that different systems/tools deal with dates differently. Excel stores dates as numbers where the number corresponds to how many days have passed since 1899-12-31:</p> <ul> <li>The date 1900-01-01 is the number 1</li> <li>The date 1900-02-01 is the number 32</li> <li>The date 2024-01-01 is the number 45292</li> </ul> Date Number Excel Formula 1900-01-01 1 <code>=TEXT(A1, \"#\")</code> 1900-01-02 2 <code>=TEXT(A2, \"#\")</code> 1900-01-03 3 <code>=TEXT(A3, \"#\")</code> ... ... 1900-01-31 31 <code>=TEXT(A5, \"#\")</code> 1900-02-01 32 <code>=TEXT(A6, \"#\")</code> 1900-02-02 33 <code>=TEXT(A7, \"#\")</code> ... ... 2024-01-01 45292 <code>=TEXT(A9, \"#\")</code> 2024-01-02 45293 <code>=TEXT(A10, \"#\")</code> 2024-01-03 45294 <code>=TEXT(A11, \"#\")</code> <p>This has many convenient implications, such as adding 1 to a date increases it by 1 day.</p>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#sql-dates-are-different-to-excel-dates","title":"SQL dates are different to Excel dates","text":"<p>SQL databases store dates differently, so applying the usual Excel-type logic to dates in SQL, such as adding the number 1 to a date won't work (in Microsoft SQL Server).</p> <p>Manipulating dates in SQL is outside the scope of this course, but it's worth getting up to speed with some of the date manipulation functions such as:</p> <ul> <li><code>DATEADD</code> for adding to or subtracting from dates</li> <li><code>DATEDIFF</code> for finding the difference between two dates</li> <li><code>DATEPART</code> for extracting parts of a date (year, quarter, day of year, etc.)</li> <li><code>YEAR</code>, <code>MONTH</code>, and <code>DAY</code> which are specific versions of <code>DATEPART</code></li> </ul>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#formatting-dates-in-sql","title":"Formatting dates in SQL","text":"<p>Although this course won't cover date manipulation, it will cover formatting dates. The two main functions to use for this are:</p> <ul> <li><code>CONVERT</code> which is good for formatting dates using pre-defined styles</li> <li><code>FORMAT</code> which is good for formatting dates using custom styles</li> </ul> <p>These functions are used in slightly different ways.</p>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#convert-has-three-parameters-and-has-some-pre-defined-styles","title":"<code>CONVERT</code> has three parameters and has some pre-defined styles","text":"<p>For <code>CONVERT</code>, you need to specify three parameters:</p> <ol> <li>The data type that you want to convert your data into, e.g. <code>VARCHAR</code></li> <li>The data that you want to convert, e.g. <code>SOME_DATE_COLUMN</code></li> <li>The style that you want to use, e.g. <code>103</code> for <code>dd/MM/yyyy</code></li> </ol> <p>The styles that you can use are all documented in the Microsoft SQL Server documentation:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql#date-and-time-styles</li> </ul> <p>Here's an example of using <code>CONVERT</code> to format some order dates:</p> <pre><code>SELECT DISTINCT TOP 5\n    OrderDate,\n    CONVERT(VARCHAR, OrderDate, 101) AS OrderDateFormatted\nFROM Sales.SalesOrderHeader\n;\n</code></pre> OrderDate OrderDateFormatted 2011-05-31 00:00:00.000 05/31/2011 2011-06-01 00:00:00.000 06/01/2011 2011-06-02 00:00:00.000 06/02/2011 2011-06-03 00:00:00.000 06/03/2011 2011-06-04 00:00:00.000 06/04/2011"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#format-has-two-required-parameters-and-is-good-for-custom-styles","title":"<code>FORMAT</code> has two (required) parameters and is good for custom styles","text":"<p>For <code>FORMAT</code>, you need to specify two parameters:</p> <ol> <li>The data that you want to format, e.g. <code>SOME_DATE_COLUMN</code></li> <li>The style that you want to use, e.g. <code>MM/dd/yyyy</code></li> </ol> <p>Similar to Excel, there are pre-defined characters which correspond to different parts of the date. For example, <code>MM</code> is the month, <code>dd</code> is the day, and <code>yyyy</code> is the year.</p> <p>These pre-defined characters are different to Excel's characters and, unlike Excel's, are case-sensitive -- you can find the SQL characters in the Microsoft SQL Server documentation:</p> <ul> <li>https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-date-and-time-format-strings#table-of-format-specifiers</li> </ul> <p>Here's an example of using <code>FORMAT</code> to format some order dates:</p> <pre><code>SELECT DISTINCT TOP 5\n    OrderDate,\n    FORMAT(OrderDate, 'MM/dd/yyyy') AS OrderDateFormatted\nFROM Sales.SalesOrderHeader\n;\n</code></pre> OrderDate OrderDateFormatted 2011-05-31 00:00:00.000 05/31/2011 2011-06-01 00:00:00.000 06/01/2011 2011-06-02 00:00:00.000 06/02/2011 2011-06-03 00:00:00.000 06/03/2011 2011-06-04 00:00:00.000 06/04/2011 <p>Note that this is the same result as the <code>CONVERT</code> example above -- there is a lot of overlap between the two functions, so it's up to you which one you use.</p>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#more-formatting-examples-and-handy-styles","title":"More formatting examples and handy styles","text":"<p>It can be a bit intimidating getting up to speed with these different styles and characters, so some of the most common ones that you'll likely need are below for reference.</p> <p>Note that some of these formats don't have a pre-defined style for <code>CONVERT</code>, so we have to use <code>FORMAT</code> for them. The examples are all how the date <code>2024-12-01</code> with the time <code>11:30:45</code> would be formatted:</p> Style (<code>CONVERT</code>) Format (<code>FORMAT</code>) Example <code>103</code> <code>dd/MM/yyyy</code> 01/12/2024 <code>106</code> <code>dd MMM yyyy</code> 01 Dec 2024 <code>108</code> <code>HH:mm:ss</code> 11:30:45 <code>120</code> <code>yyyy-MM-dd HH:mm:ss</code> 2024-12-01 11:30:45 <code>109</code> <code>MMM d yyyy HH:mm:ss:ffftt</code> Dec 1 2024 11:30:45:000AM <code>yyyy-MM</code> 2024-12 <code>MMM-yy</code> Dec-24 <code>MMMM yyyy</code> December 2024 <code>dddd, dd MMMM yyyy</code> Sunday, 01 December 2024 Expand for some SQL to run yourself  These are more examples created just for this course, so they aren't in the AdventureWorks database. If you want to run these examples yourself, you can use the SQL below -- but note that this is using some features that we haven't covered yet!  <pre><code>SELECT\n    CONVERT(VARCHAR, EXAMPLE_DATE, 103),\n    FORMAT(EXAMPLE_DATE, 'dd/MM/yyyy'),\n    CONVERT(VARCHAR, EXAMPLE_DATE, 106),\n    FORMAT(EXAMPLE_DATE, 'dd MMM yyyy'),\n    CONVERT(VARCHAR, EXAMPLE_DATE, 108),\n    FORMAT(EXAMPLE_DATE, 'HH:mm:ss'),\n    CONVERT(VARCHAR, EXAMPLE_DATE, 120),\n    FORMAT(EXAMPLE_DATE, 'yyyy-MM-dd HH:mm:ss'),\n    CONVERT(VARCHAR, EXAMPLE_DATE, 109),\n    FORMAT(EXAMPLE_DATE, 'MMM d yyyy HH:mm:ss:ffftt'),\n    FORMAT(EXAMPLE_DATE, 'yyyy-MM'),\n    FORMAT(EXAMPLE_DATE, 'MMM-yy'),\n    FORMAT(EXAMPLE_DATE, 'MMMM yyyy'),\n    FORMAT(EXAMPLE_DATE, 'dddd, dd MMMM yyyy')\nFROM (\n    VALUES (CAST('2024-12-01 11:30:45' AS DATETIME))\n) AS V(EXAMPLE_DATE)\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on <code>CONVERT</code> and <code>FORMAT</code> at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/format-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/gYjYLL99jaQ</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/date-formatting/#additional-date-functions","title":"Additional date functions","text":"<p>Manipulating dates in SQL is fairly different to Excel, but it's outside the scope of this course. However, it's recommended that you check some out to see what options are available:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/dateadd-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/datediff-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/datepart-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/year-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/month-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/day-transact-sql</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/group-by/","title":"Aggregations \ud83d\udcca","text":"<p>Success</p> <p>One of the most common ways to use SQL is to aggregate data!</p> <p>Note</p> <p>The <code>GROUP BY</code> clause is optional. If you use it, it must come after the <code>WHERE</code> clause and before the <code>ORDER BY</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/group-by/#there-are-two-parts-to-aggregating-data","title":"There are two parts to aggregating data","text":"<p>By now, we know how to get some data, how to filter it, how to sort it, and how to do some simple manipulations on it.</p> <p>To aggregate rows, use aggregate functions and the <code>GROUP BY</code> clause.</p> <p>Let's break this down into the two parts: aggregate functions and the <code>GROUP BY</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/group-by/#the-aggregate-functions-are-how-we-aggregate-the-data","title":"The aggregate functions are how we aggregate the data","text":"<p>Info</p> <p>\"Aggregating\" data is just a fancy way of saying \"summarising\" data, such as counting the number of rows, finding the average of a column, finding the maximum value in a column, and so on.</p> <p>To tell SQL that we want to aggregate rows, we use some of these \"aggregate functions\". These functions are used after the <code>SELECT</code> clause where we'd normally list the columns.</p> <p>SQL has a bunch of aggregate functions, but the most common ones are:</p> <ul> <li><code>COUNT</code>, which counts the number of rows</li> <li><code>SUM</code>, which adds up the values in a column</li> <li><code>AVG</code>, which finds the average of the values in a column</li> <li><code>MIN</code>, which finds the minimum value in a column</li> <li><code>MAX</code>, which finds the maximum value in a column</li> </ul> <p>If we want to aggregate/summarise a table, we can just use one of these functions in the <code>SELECT</code> clause. For example:</p> <pre><code>SELECT\n    /* We'll explain these `COUNT` contents below */\n    COUNT(*) AS TotalRows,\n    COUNT(DISTINCT SalesOrderID) AS TotalOrders,\n\n    AVG(1.0 * OrderQty) AS AverageOrderQuantity,\n    SUM(LineTotal) AS TotalSalesAmount,\n    MIN(ModifiedDate) AS FirstModifiedDate,\n    MAX(ModifiedDate) AS LastModifiedDate\nFROM Sales.SalesOrderDetail\n;\n</code></pre> TotalRows TotalOrders AverageOrderQuantity TotalSalesAmount FirstModifiedDate LastModifiedDate 121317 31465 2.266079 109846381.399888 2011-05-31 00:00:00.000 2014-06-30 00:00:00.000 <p>Info</p> <p>Do you remember why we have had to use <code>1.0 * OrderQty</code> inside the <code>AVG</code> function?</p> <p>See the Operators section for a refresher.</p> <p>Without the <code>GROUP BY</code> clause, these functions will aggregate the entire table, so we get a single row as a result.</p> <p>However, it's super common to want to aggregate data by some grouping, such as by a category or by a time period. This is where the <code>GROUP BY</code> clause comes in!</p> <p>Success</p> <p>Summarising data like this is like using summary functions in Excel over an entire column, such as <code>=SUM(A:A)</code>!</p>"},{"location":"from-excel-to-sql/main-concepts/group-by/#count-can-be-used-in-a-few-ways","title":"<code>COUNT</code> can be used in a few ways","text":"<p>Before jumping into the <code>GROUP BY</code> clause, let's take a closer look at the <code>COUNT</code> function. For some column called <code>COLUMN_NAME</code>, the main ways to use <code>COUNT</code> are described below:</p> <ul> <li><code>COUNT(*)</code> counts the number of rows in the table/group</li> <li><code>COUNT(COLUMN_NAME)</code> counts the number of non-<code>NULL</code> values in the column/group</li> <li><code>COUNT(DISTINCT COLUMN_NAME)</code> counts the number of unique values in the column/group</li> </ul> <p>Each way of using <code>COUNT</code> has its own use case, and you'll see all of them out in the wild.</p> <p>Let's see these three ways of using <code>COUNT</code> in action on the first 10 people in the <code>Person.Person</code> table:</p> <pre><code>SELECT\n    BusinessEntityID,\n    FirstName,\n    MiddleName,\n    LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt;= 10\n;\n</code></pre> BusinessEntityID FirstName MiddleName LastName 1 Ken J S\u00e1nchez 2 Terri Lee Duffy 3 Roberto null Tamburello 4 Rob null Walters 5 Gail A Erickson 6 Jossef H Goldberg 7 Dylan A Miller 8 Diane L Margheim 9 Gigi N Matthew 10 Michael null Raheem <p>The <code>MiddleName</code> has a variety of values, including <code>NULL</code>. Here are the results of the three ways of using <code>COUNT</code> on this column for these rows:</p> <pre><code>SELECT\n    COUNT(*) AS ROW_COUNT,\n    COUNT(MiddleName) AS NON_NULL_COUNT,\n    COUNT(DISTINCT MiddleName) AS DISTINCT_COUNT\nFROM Person.Person\nWHERE BusinessEntityID &lt;= 10\n;\n</code></pre> ROW_COUNT NON_NULL_COUNT DISTINCT_COUNT 10 7 6 <p>The <code>ROW_COUNT</code> is just the number of rows, which is 10. The <code>NON_NULL_COUNT</code> is the number of non-<code>NULL</code> values, which is 7. The <code>DISTINCT_COUNT</code> is the number of unique values, which is 6. In particular, they are:</p> <ul> <li><code>J</code></li> <li><code>Lee</code></li> <li><code>A</code></li> <li><code>H</code></li> <li><code>L</code></li> <li><code>N</code></li> </ul> <p>Note how the <code>NULL</code> values are not counted in the <code>DISTINCT_COUNT</code> -- this is a common behaviour in SQL.</p> <p>Tip</p> <p>Since each of the ways above has a different use case, make sure you use the right one for your needs!</p>"},{"location":"from-excel-to-sql/main-concepts/group-by/#the-group-by-clause-summarises-data-by-a-category-or-categories","title":"The <code>GROUP BY</code> clause summarises data by a category (or categories)","text":"<p>Note</p> <p>To tell SQL that we want to aggregate rows by a category (or categories), we use the <code>GROUP BY</code> clause. This clause comes after the <code>WHERE</code> clause and before the <code>ORDER BY</code> clause.</p> <p>The examples above are just producing a single row with the \"overall\" aggregate/summary values.</p> <p>Using the <code>GROUP BY</code> clause allows us to group the data by one or more columns.</p> <p>To help illustrate why this is helpful, it might be useful to think about what kind of questions you can answer with this.</p> <p>Without the <code>GROUP BY</code> clause, the kinds of questions you can answer are things like:</p> <ul> <li>\"What are the total sales over all orders?\"</li> <li>\"What is the average order quantity over all orders?\"</li> <li>\"What is the minimum and maximum unit price over all orders?\"</li> </ul> <p>With the <code>GROUP BY</code> clause, you can answer questions like:</p> <ul> <li>\"What are the total sales per order?\"</li> <li>\"What is the average order quantity per month?\"</li> <li>\"What is the minimum and maximum unit price per product?\"</li> </ul> <p>To see this in action, the example above can be adjusted to group by the <code>SalesOrderID</code> column which would give us the summary statistics for each order:</p> <pre><code>SELECT TOP 5\n    SalesOrderID,\n\n    COUNT(*) AS TotalRowsInOrder,\n    AVG(1.0 * OrderQty) AS AverageOrderQuantity,\n    SUM(OrderQty) AS TotalItemsOrdered,\n    SUM(LineTotal) AS TotalSalesAmount,\n    MIN(UnitPrice) AS CheapestItemPrice,\n    MAX(UnitPrice) AS MostExpensiveItemPrice\nFROM Sales.SalesOrderDetail\nGROUP BY SalesOrderID\n;\n</code></pre> SalesOrderID TotalRowsInOrder AverageOrderQuantity TotalItemsOrdered TotalSalesAmount CheapestItemPrice MostExpensiveItemPrice 43659 12 2.166666 26 20565.620600 5.1865 2039.9940 43660 2 1.000000 2 1294.252900 419.4589 874.7940 43661 15 2.533333 38 32726.478600 5.1865 2039.9940 43662 22 2.454545 54 28832.528900 178.5808 2146.9620 43663 1 1.000000 1 419.458900 419.4589 419.4589"},{"location":"from-excel-to-sql/main-concepts/group-by/#calculated-columns-need-to-be-re-calculated-in-the-group-by-clause","title":"Calculated columns need to be \"re-calculated\" in the <code>GROUP BY</code> clause","text":"<p>Info</p> <p>This is not the case for many SQL dialects, but it is for Microsoft SQL Server.</p> <p>If you want to group by a column that is calculated in the <code>SELECT</code> clause, you need to repeat the calculation in the <code>GROUP BY</code> clause.</p> <p>For example, if we wanted to aggregate the sales by the order month, we would need to convert the order date into a month both in the <code>SELECT</code> and the <code>GROUP BY</code> lists:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE YEAR(OrderDate) = 2013\nGROUP BY FORMAT(OrderDate, 'yyyy-MM')\nORDER BY OrderMonth\n;\n</code></pre> OrderMonth TotalSales 2013-01 2340061.5521 2013-02 2600218.8667 2013-03 3831605.9389 2013-04 2840711.1734 2013-05 3658084.9461 2013-06 5726265.2635 2013-07 5521840.8445 2013-08 3733973.0032 2013-09 5083505.3374 2013-10 5374375.9418 2013-11 3694667.9998 2013-12 4560577.0958 <p>Remember that we don't need to repeat the calculation in the <code>ORDER BY</code> clause though -- it's one of the few places where we can use the alias.</p>"},{"location":"from-excel-to-sql/main-concepts/group-by/#you-can-group-by-one-or-more-columns","title":"You can group by one or more columns","text":"<p>To group by more than one column, list the columns in the <code>GROUP BY</code> clause!</p> <p>The example below is a more involved query to show how we can calculate the total sales for each month in 2013, split by whether the order was placed online or not:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE YEAR(OrderDate) = 2013\nGROUP BY\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> OrderMonth OnlineOrderFlag TotalSales 2013-01 false 1761132.8322 2013-01 true 578928.7199 2013-02 false 2101152.5476 2013-02 true 499066.3191 2013-03 false 3244501.4287 2013-03 true 587104.5102 2013-04 false 2239156.6675 2013-04 true 601554.5059 2013-05 false 3019173.6253 2013-05 true 638911.3208 2013-06 false 4775809.3027 2013-06 true 950455.9608 2013-07 false 4585752.5978 2013-07 true 936088.2467 2013-08 false 2573825.2983 2013-08 true 1160147.7049 2013-09 false 3927650.1373 2013-09 true 1155855.2001 2013-10 false 3954900.7112 2013-10 true 1419475.2306 2013-11 false 1878956.5046 2013-11 true 1815711.4952 2013-12 false 3044875.2799 2013-12 true 1515701.8159 <p>Although SQL itself doesn't have any graphing capabilities, this would be easy to drop into Excel or a similar tool to create a graph like the one below!</p> <pre><code>xychart-beta\n    title \"Monthly Sales (2013) by Online Order Flag\"\n    x-axis \"Offline Orders (Bar) | Online Orders (Line)\" [Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec]\n    bar \"Offline Orders\" [1761132.8322, 2101152.5476, 3244501.4287, 2239156.6675, 3019173.6253, 4775809.3027, 4585752.5978, 2573825.2983, 3927650.1373, 3954900.7112, 1878956.5046, 3044875.2799]\n    line \"Online Orders\" [578928.7199, 499066.3191, 587104.5102, 601554.5059, 638911.3208, 950455.9608, 936088.2467, 1160147.7049, 1155855.2001, 1419475.2306, 1815711.4952, 1515701.8159]</code></pre>"},{"location":"from-excel-to-sql/main-concepts/group-by/#you-can-filter-the-aggregated-rows-with-having","title":"You can filter the aggregated rows with <code>HAVING</code>","text":"<p>Note</p> <p>The <code>HAVING</code> clause is optional. If you use it, it must come after the <code>GROUP BY</code> clause.</p> <p>A handy way to filter the aggregated rows is to use the <code>HAVING</code> clause. This clause is similar to the <code>WHERE</code> clause, but it filters the aggregated rows -- that is, it does the filtering after the aggregation.</p> <p>To use the <code>HAVING</code> clause, add it after the <code>GROUP BY</code> clause. For example, we could extend the monthly summary example above to keep only the months when the total sales were more than $5m:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE YEAR(OrderDate) = 2013\nGROUP BY FORMAT(OrderDate, 'yyyy-MM')\nHAVING SUM(TotalDue) &gt; 5000000\nORDER BY OrderMonth\n;\n</code></pre> OrderMonth TotalSales 2013-06 5726265.2635 2013-07 5521840.8445 2013-09 5083505.3374 2013-10 5374375.9418 <p>Warning</p> <p>There are two things to be careful of with the <code>HAVING</code> clause:</p> <ol> <li>This is similar to the <code>WHERE</code> clause, but it is not the same. Reserve it for filtering by aggregated values and continue to use the <code>WHERE</code> clause for filtering the original/underlying rows.</li> <li>You cannot use column aliases in the <code>HAVING</code> clause, so you need to repeat the calculation.</li> </ol>"},{"location":"from-excel-to-sql/main-concepts/group-by/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>GROUP BY</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-group-by-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/aggregate-functions-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/Tlckp6UbmQE</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/group-by/#additional-modifiers","title":"Additional modifiers","text":"<p>The <code>GROUP BY</code> clause also has additional modifiers including <code>ROLLUP</code>, <code>GROUPING SETS</code>, and <code>CUBE</code>. We'll see <code>ROLLUP</code> in the next section and both <code>GROUPING SETS</code> and <code>CUBE</code> and the advanced aggregations section.</p>"},{"location":"from-excel-to-sql/main-concepts/join/","title":"Joins \ud83d\udd17","text":"<p>Success</p> <p>Joins are how we combine data from multiple tables. They're like the <code>LOOKUP</code> functions in Excel (but with some important differences)!</p> <p>Note</p> <p>The <code>JOIN</code> clause is optional. If you use it, it must come after the <code>FROM</code> clause and before the <code>WHERE</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#the-join-clause-combines-data-from-tables","title":"The <code>JOIN</code> clause combines data from tables","text":"<p>To get data from another table in Excel, you'd likely use one of the <code>LOOKUP</code> functions:</p> <ul> <li><code>VLOOKUP</code></li> <li><code>HLOOKUP</code></li> <li><code>XLOOKUP</code></li> </ul> <p>These functions keep your data in the same shape as the original table, but they pull in data from another table based on a common value.</p> <p>In SQL, we use the <code>JOIN</code> clause to do a similar thing. The <code>JOIN</code> clause is used to combine rows between tables based on a related column between them (usually).</p> <p>In Microsoft SQL Server, there are a few different types of <code>JOIN</code> clauses:</p> <ul> <li><code>INNER JOIN</code></li> <li><code>LEFT JOIN</code></li> <li><code>RIGHT JOIN</code></li> <li><code>FULL JOIN</code></li> <li><code>CROSS JOIN</code></li> </ul> <p>We'll only cover the <code>INNER JOIN</code> and <code>LEFT JOIN</code> in this course, but you can find more information on the others in the official Microsoft documentation.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#the-join-syntax","title":"The <code>JOIN</code> syntax","text":"<p>To add a join to a query, you need to add the <code>JOIN</code> clause after the <code>FROM</code> clause and before the <code>WHERE</code> clause. We also need to tell SQL how these tables are related using the <code>ON</code> clause, for example:</p> <pre><code>SELECT *\nFROM HumanResources.Employee\n    INNER JOIN HumanResources.vEmployeeDepartment\n        ON Employee.BusinessEntityID = vEmployeeDepartment.BusinessEntityID\n;\n</code></pre> <p>This is a fairly intuitive example:</p> <ul> <li>The \"base\" table (in the <code>FROM</code> clause) is <code>HumanResources.Employee</code> which has the employee information.</li> <li>The \"joined\" table (in the <code>INNER JOIN</code> clause) is <code>HumanResources.vEmployeeDepartment</code> which has the employee's current department.</li> <li>The relationship between the two tables is that the <code>BusinessEntityID</code> in the <code>Employee</code> table matches the <code>BusinessEntityID</code> in the <code>vEmployeeDepartment</code> table. This would be similar to the <code>VLOOKUP</code> function in Excel where the <code>Employee.BusinessEntityID</code> is the lookup value and the <code>vEmployeeDepartment.BusinessEntityID</code> is the lookup column.</li> </ul> <p>Notice how we've had to prefix the <code>BusinessEntityID</code> with the table name in the <code>ON</code> clause. This is because both tables have this column, so SQL needs us to prefix them to know which one we're referring to.</p> <p>When we join tables, we don't usually want to <code>SELECT *</code> like we have above. Instead, we explicitly list the columns we want to see from each table:</p> <pre><code>SELECT\n    Employee.BusinessEntityID,\n    Employee.NationalIDNumber,\n    vEmployeeDepartment.FirstName,\n    vEmployeeDepartment.LastName,\n    vEmployeeDepartment.Department,\n    vEmployeeDepartment.JobTitle\nFROM HumanResources.Employee\n    LEFT JOIN HumanResources.vEmployeeDepartment\n        ON Employee.BusinessEntityID = vEmployeeDepartment.BusinessEntityID\n;\n</code></pre> BusinessEntityID NationalIDNumber FirstName LastName Department JobTitle 1 295847284 Ken S\u00e1nchez Executive Chief Executive Officer 2 245797967 Terri Duffy Engineering Vice President of Engineering 3 509647174 Roberto Tamburello Engineering Engineering Manager 4 112457891 Rob Walters Tool Design Senior Tool Designer 5 695256908 Gail Erickson Engineering Design Engineer <p>Tip</p> <p>Although you only need to prefix the columns that are ambiguous (exist in both tables), it's a good idea to prefix all columns in a query when there's a join. This makes it easier to read and understand the query, and it can help avoid errors if the tables change in the future.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#we-can-aliasrename-tables-like-we-can-with-columns","title":"We can alias/rename tables like we can with columns","text":"<p>When the table names are long, it can be helpful to give them a shorter name for the rest of the query. The way that we do this is identical to how we alias columns by using the <code>AS</code> keyword:</p> <pre><code>SELECT\n    Emp.BusinessEntityID,\n    Emp.NationalIDNumber,\n    Dep.FirstName,\n    Dep.LastName,\n    Dep.Department,\n    Dep.JobTitle\nFROM HumanResources.Employee AS Emp\n    LEFT JOIN HumanResources.vEmployeeDepartment AS Dep\n        ON Emp.BusinessEntityID = Dep.BusinessEntityID\n;\n</code></pre> <p>Tip</p> <p>Although you can alias the tables to whatever you want, please try to make the alias meaningful. This makes the query easier to read and understand!</p>"},{"location":"from-excel-to-sql/main-concepts/join/#step-by-step-examples","title":"Step-by-step examples","text":"<p>We've just seen the <code>LEFT JOIN</code> clause in action, but let's break it down a bit more with some examples.</p> <p>For these examples, we'll use the following fake tables:</p> <p><code>Employee</code></p> EmployeeID EmployeeName DepartmentID 1 Alice 1 2 Bob 1 3 Charlie 2 4 Dave 2 5 Eve 3 <p><code>Department</code></p> DepartmentID DepartmentName 1 Sales 2 Marketing <p><code>Address</code></p> EmployeeID Address FromDate ToDate 1 1 Main Street 2001-07-21 2002-10-30 2 2 Rocky Road 2012-07-04 2018-02-11 5 5 Log Lane 2009-11-19 2020-03-15 5 6 Claw Close 2023-03-16 2024-12-31"},{"location":"from-excel-to-sql/main-concepts/join/#employee-left-join-department","title":"<code>Employee LEFT JOIN Department</code>","text":"<p>Suppose we write a query that <code>LEFT JOIN</code>s the <code>Department</code> table onto the <code>Employee</code> table using the <code>DepartmentID</code>:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName\nFROM Employee\n    LEFT JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n;\n</code></pre> <p>Since the <code>Employee</code> table is the \"base\" table (it's in the <code>FROM</code> clause), let's break down what's happening with each row in this table.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-1","title":"Employee 1","text":"<p>The first row is employee 1:</p> EmployeeID EmployeeName DepartmentID 1 Alice 1 <p>We're joining the <code>Department</code> table to this on the <code>DepartmentID</code> column, specifically:</p> <pre><code>ON Employee.DepartmentID = Department.DepartmentID\n</code></pre> <p>This means that the information we get from the <code>Department</code> table will be where the <code>DepartmentID</code> in the <code>Department</code> table matches the <code>DepartmentID</code> in the <code>Employee</code> table which, in this case, is 1:</p> DepartmentID DepartmentName \u2192 1 Sales 2 Marketing <p>That means that we take the <code>Sales</code> value from this table for the first row of the <code>Employee</code> table:</p> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales <p>This is just like a lookup in Excel!</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-2","title":"Employee 2","text":"<p>The second row is employee 2:</p> EmployeeID EmployeeName DepartmentID 2 Bob 1 <p>Bob has the same <code>DepartmentID</code> as Alice, so the steps for Bob are the same as they were for Alice -- we get the <code>Sales</code> value from the <code>Department</code> table:</p> EmployeeID EmployeeName DepartmentID DepartmentName 2 Bob 1 Sales"},{"location":"from-excel-to-sql/main-concepts/join/#employee-3","title":"Employee 3","text":"<p>The third row is employee 3:</p> EmployeeID EmployeeName DepartmentID 3 Charlie 2 <p>This time, the <code>DepartmentID</code> is 2:</p> DepartmentID DepartmentName 1 Sales \u2192 2 Marketing <p>Therefore, we get the <code>Marketing</code> value from the <code>Department</code> table for Charlie:</p> EmployeeID EmployeeName DepartmentID DepartmentName 3 Charlie 2 Marketing"},{"location":"from-excel-to-sql/main-concepts/join/#employee-4","title":"Employee 4","text":"<p>The fourth row is employee 4:</p> EmployeeID EmployeeName DepartmentID 4 Dave 2 <p>Dave also has a <code>DepartmentID</code> of 2, so we take the <code>Marketing</code> value from the <code>Department</code> table for Dave:</p> EmployeeID EmployeeName DepartmentID DepartmentName 4 Dave 2 Marketing"},{"location":"from-excel-to-sql/main-concepts/join/#employee-5","title":"Employee 5","text":"<p>The fifth row is employee 5:</p> EmployeeID EmployeeName DepartmentID 5 Eve 3 <p>This is an interesting case. Eve has a <code>DepartmentID</code> of 3, but there's no <code>DepartmentID</code> of 3 in the <code>Department</code> table:</p> DepartmentID DepartmentName 1 Sales 2 Marketing <p>This means that we can't find a <code>DepartmentName</code> for Eve, so we instead get a <code>NULL</code> value for the <code>DepartmentName</code>:</p> EmployeeID EmployeeName DepartmentID DepartmentName 5 Eve 3 NULL"},{"location":"from-excel-to-sql/main-concepts/join/#putting-it-all-together","title":"Putting it all together","text":"<p>When we put all of these rows together, we get the following result:</p> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales 2 Bob 1 Sales 3 Charlie 2 Marketing 4 Dave 2 Marketing 5 Eve 3 null <p>This is how the <code>LEFT JOIN</code> clause works -- it grabs whatever data it can from the \"joined\" table and fills in <code>NULL</code> values where it can't find a match.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-inner-join-department","title":"<code>Employee INNER JOIN Department</code>","text":"<p>Now let's look at the <code>INNER JOIN</code> clause. We'll use the exact same query as the last example, but we'll change the <code>LEFT JOIN</code> to an <code>INNER JOIN</code>:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName\nFROM Employee\n    INNER JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n;\n</code></pre> <p>We could find a match for the first four rows, so they are the same as they were in the <code>LEFT JOIN</code> example:</p> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales 2 Bob 1 Sales 3 Charlie 2 Marketing 4 Dave 2 Marketing <p>However, what happens with employee 5 is different: an <code>INNER JOIN</code> only keeps rows where there's a match!</p> <p>Since there's no match for employee 5 in the <code>Department</code> table, we don't get a row for Eve at all! This means that the result of the <code>INNER JOIN</code> is:</p> EmployeeID EmployeeName DepartmentID DepartmentName 1 Alice 1 Sales 2 Bob 1 Sales 3 Charlie 2 Marketing 4 Dave 2 Marketing <p>This is the main difference between the <code>LEFT JOIN</code> and the <code>INNER JOIN</code> clauses and is what catches a lot of people out when they're new to SQL.</p> <p>Tip</p> <p>If you're not sure which join type to use, it's usually best to start with a <code>LEFT JOIN</code> and then change it to an <code>INNER JOIN</code> when you're comfortable that you're not missing any data.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-left-join-address","title":"<code>Employee LEFT JOIN Address</code>","text":"<p>This time, suppose we write a query that <code>LEFT JOIN</code>s the <code>Address</code> table onto the <code>Employee</code> table using the <code>EmployeeID</code>:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    LEFT JOIN Address\n        ON Employee.EmployeeID = Address.EmployeeID\n;\n</code></pre> <p>As with the last example, we'll break down what's happening with each row in the <code>Employee</code> table. We'll ignore the <code>DepartmentID</code> column in the <code>Employee</code> since we're not using it in the query.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-1_1","title":"Employee 1","text":"<p>The first row is employee 1:</p> EmployeeID EmployeeName 1 Alice <p>This time, we're joining the <code>Address</code> table to this on the <code>EmployeeID</code> column, specifically:</p> <pre><code>ON Employee.EmployeeID = Address.EmployeeID\n</code></pre> <p>This means that the information we get from the <code>Address</code> table will be where the <code>EmployeeID</code> in the <code>Address</code> table matches the <code>EmployeeID</code> in the <code>Employee</code> table which, in this case, is 1:</p> EmployeeID Address FromDate ToDate \u2192 1 1 Main Street 2001-07-21 2002-10-30 2 2 Rocky Road 2012-07-04 2018-02-11 5 5 Log Lane 2009-11-19 2020-03-15 5 6 Claw Close 2023-03-16 2024-12-31 <p>That means that we take the <code>1 Main Street</code> address (plus the dates) from this table for the first row of the <code>Employee</code> table:</p> EmployeeID EmployeeName Address FromDate ToDate 1 Alice 1 Main Street 2001-07-21 2002-10-30"},{"location":"from-excel-to-sql/main-concepts/join/#employee-2_1","title":"Employee 2","text":"<p>The second row is employee 2:</p> EmployeeID EmployeeName 2 Bob <p>Bob's <code>EmployeeID</code> is 2, so we look for the address in the <code>Address</code> table where the <code>EmployeeID</code> is 2:</p> EmployeeID Address FromDate ToDate 1 1 Main Street 2001-07-21 2002-10-30 \u2192 2 2 Rocky Road 2012-07-04 2018-02-11 5 5 Log Lane 2009-11-19 2020-03-15 5 6 Claw Close 2023-03-16 2024-12-31 <p>This means that we get the <code>2 Rocky Road</code> address (plus the dates) from the <code>Address</code> table for Bob:</p> EmployeeID EmployeeName Address FromDate ToDate 2 Bob 2 Rocky Road 2012-07-04 2018-02-11"},{"location":"from-excel-to-sql/main-concepts/join/#employee-3_1","title":"Employee 3","text":"<p>The third row is employee 3:</p> EmployeeID EmployeeName 3 Charlie <p>Charlie's <code>EmployeeID</code> is 3, so we look for the address in the <code>Address</code> table where the <code>EmployeeID</code> is 3:</p> EmployeeID Address FromDate ToDate 1 1 Main Street 2001-07-21 2002-10-30 2 2 Rocky Road 2012-07-04 2018-02-11 5 5 Log Lane 2009-11-19 2020-03-15 5 6 Claw Close 2023-03-16 2024-12-31 <p>Since we can't find a match for Charlie and we're using a <code>LEFT JOIN</code>, we'll get <code>NULL</code> values for the <code>Address</code> columns:</p> EmployeeID EmployeeName Address FromDate ToDate 3 Charlie null null null"},{"location":"from-excel-to-sql/main-concepts/join/#employee-4_1","title":"Employee 4","text":"<p>The fourth row is employee 4:</p> EmployeeID EmployeeName 4 Dave <p>Dave's <code>EmployeeID</code> is 4 which also doesn't have a match in the <code>Address</code> table, so we get <code>NULL</code> values for the <code>Address</code> columns:</p> EmployeeID EmployeeName Address FromDate ToDate 4 Dave null null null"},{"location":"from-excel-to-sql/main-concepts/join/#employee-5_1","title":"Employee 5","text":"<p>The fifth row is employee 5:</p> EmployeeID EmployeeName 5 Eve <p>Eve's <code>EmployeeID</code> is 5, and they have two addresses in the <code>Address</code> table:</p> EmployeeID Address FromDate ToDate 1 1 Main Street 2001-07-21 2002-10-30 2 2 Rocky Road 2012-07-04 2018-02-11 \u2192 5 5 Log Lane 2009-11-19 2020-03-15 \u2192 5 6 Claw Close 2023-03-16 2024-12-31 <p>This is another place where SQL is different to Excel. Since we have two matches for Eve in the <code>Address</code> table, we get two rows in the result -- we keep both!</p> EmployeeID EmployeeName Address FromDate ToDate 5 Eve 5 Log Lane 2009-11-19 2020-03-15 5 Eve 6 Claw Close 2023-03-16 2024-12-31"},{"location":"from-excel-to-sql/main-concepts/join/#putting-it-all-together_1","title":"Putting it all together","text":"<p>When we put all of these rows together, we get the following result:</p> EmployeeID EmployeeName Address FromDate ToDate 1 Alice 1 Main Street 2001-07-21 2002-10-30 2 Bob 2 Rocky Road 2012-07-04 2018-02-11 3 Charlie null null null 4 Dave null null null 5 Eve 5 Log Lane 2009-11-19 2020-03-15 5 Eve 6 Claw Close 2023-03-16 2024-12-31 <p>Warning</p> <p>In Excel, you'd only get one row for Eve (Excel would just keep the first match), but in SQL you get all the matches. This is a common source of confusion for people new to SQL.</p> <p>However, this behaviour is super useful when used correctly! Just keep an eye out for it.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#employee-inner-join-address","title":"<code>Employee INNER JOIN Address</code>","text":"<p>To finish off, let's consider the same query but with an <code>INNER JOIN</code> instead of a <code>LEFT JOIN</code>:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    INNER JOIN Address\n        ON Employee.EmployeeID = Address.EmployeeID\n;\n</code></pre> <p>Can you guess what the result will be?</p> <p>It's the same as the <code>LEFT JOIN</code> example, but without rows for Charlie and Dave since they don't have a match in the <code>Address</code> table using this condition:</p> EmployeeID EmployeeName Address FromDate ToDate 1 Alice 1 Main Street 2001-07-21 2002-10-30 2 Bob 2 Rocky Road 2012-07-04 2018-02-11 5 Eve 5 Log Lane 2009-11-19 2020-03-15 5 Eve 6 Claw Close 2023-03-16 2024-12-31"},{"location":"from-excel-to-sql/main-concepts/join/#left-join-is-probably-the-most-common-join-type","title":"<code>LEFT JOIN</code> is probably the most common join type","text":"<p>Since the <code>INNER JOIN</code> will drop rows that don't have a match in the \"joined\" table, it's usually \"safer\" to use <code>LEFT JOIN</code> to make sure that you don't accidentally lose any data during the join.</p> <p>This is common practice (favouring <code>LEFT</code> over <code>INNER</code>), so you'll often see people use <code>LEFT JOIN</code> unless they have a specific reason to use a different type.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#inner-join-is-the-default-join-type","title":"<code>INNER JOIN</code> is the default join type","text":"<p>If you don't specify <code>LEFT</code> or <code>INNER</code> (or any of the others), then SQL will default to an <code>INNER JOIN</code>:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName\nFROM Employee\n    JOIN Department  /* This will be an `INNER JOIN` */\n        ON Employee.DepartmentID = Department.DepartmentID\n;\n</code></pre> <p>Although this is the default, it's always a good idea to be explicit about the join type you're using. This makes the query easier to read and understand, and it can help avoid errors if the tables change in the future.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#there-can-be-several-joins-in-a-single-query","title":"There can be several joins in a single query","text":"<p>The examples above have just been joining two tables, but you can join as many tables as you like in a single query.</p> <p>For example, we could combine the <code>Employee</code>, <code>Department</code>, and <code>Address</code> tables in a single query:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    LEFT JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n    LEFT JOIN Address\n        ON Employee.EmployeeID = Address.EmployeeID\n;\n</code></pre> EmployeeID EmployeeName DepartmentID DepartmentName Address FromDate ToDate 1 Alice 1 Sales 1 Main Street 2001-07-21 2002-10-30 2 Bob 1 Sales 2 Rocky Road 2012-07-04 2018-02-11 3 Charlie 2 Marketing null null null 4 Dave 2 Marketing null null null 5 Eve 3 null 5 Log Lane 2009-11-19 2020-03-15 5 Eve 3 null 6 Claw Close 2020-03-16 2024-12-31 <p>Notice how, although the <code>Employee</code> table only has five rows, we've ended up with six because of the (<code>LEFT</code>) join with the <code>Address</code> table.</p> <p>Similarly, can you guess what the output would be if we used <code>INNER JOIN</code>s instead of <code>LEFT JOIN</code>s?</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    INNER JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n    INNER JOIN Address\n        ON Employee.EmployeeID = Address.EmployeeID\n;\n</code></pre> EmployeeID EmployeeName DepartmentID DepartmentName Address FromDate ToDate 1 Alice 1 Sales 1 Main Street 2001-07-21 2002-10-30 2 Bob 1 Sales 2 Rocky Road 2012-07-04 2018-02-11 <p>We'd only get two rows! We'd lose the rows for Charlie and Dave in the join with the <code>Address</code> table, and we'd lose the row(s) for Eve in the join with the <code>Department</code> table.</p> <p>Info</p> <p>You can use whichever join types you want for each join, there's no need to use all the same (e.g. all <code>LEFT</code> join).</p>"},{"location":"from-excel-to-sql/main-concepts/join/#other-tips-and-tricks","title":"Other tips and tricks","text":"<p>The examples above are \"typical\" examples of joins, but you'll find that you can use joins in a lot of different ways!</p>"},{"location":"from-excel-to-sql/main-concepts/join/#you-can-use-any-condition-in-a-join","title":"You can use any condition in a join","text":"<p>We've just been using the <code>=</code> operator in the <code>ON</code> clause, but you can use any condition you like (and as many as you want!).</p> <p>For example, we could also filter on the dates in the <code>Address</code> table when we join it to the <code>Employee</code> table:</p> <pre><code>SELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    INNER JOIN Address\n        ON  Employee.EmployeeID = Address.EmployeeID\n        AND Address.FromDate &gt;= '2010-01-01'\n;\n</code></pre> EmployeeID EmployeeName Address FromDate ToDate 2 Bob 2 Rocky Road 2012-07-04 2018-02-11 5 Eve 6 Claw Close 2020-03-16 2024-12-31"},{"location":"from-excel-to-sql/main-concepts/join/#tables-can-be-joined-to-themselves","title":"Tables can be joined to themselves","text":"<p>There's nothing stopping you from joining a table to itself! This can be useful when you want to compare rows within the same table, but this is pretty rare, so we won't cover it in this course.</p>"},{"location":"from-excel-to-sql/main-concepts/join/#the-sql-for-running-these-examples","title":"The SQL for running these examples","text":"<p>Danger</p> <p>The data for these examples isn't in the AdventureWorks database that we're using, so it has been created for this section. If you want to run these examples yourself, you can adjust the SQL below. Note that this is using some features that we haven't covered yet!</p> <p>For the examples above, the rows are created on the fly. You're not expected to understand this yet, but it's provided so that you can run the SQL yourself if you want to.</p> <pre><code>WITH\n\nEmployee AS (\n    SELECT *\n    FROM (\n        VALUES\n            (1, 'Alice',   1),\n            (2, 'Bob',     1),\n            (3, 'Charlie', 2),\n            (4, 'Dave',    2),\n            (5, 'Eve',     3)\n    ) AS V(EmployeeID, EmployeeName, DepartmentID)\n),\n\nDepartment AS (\n    SELECT *\n    FROM (\n        VALUES\n            (1, 'Sales'),\n            (2, 'Marketing')\n    ) AS V(DepartmentID, DepartmentName)\n),\n\nAddress AS (\n    SELECT *\n    FROM (\n        VALUES\n            (1, '1 Main Street', '2001-07-21', '2002-10-30'),\n            (2, '2 Rocky Road',  '2012-07-04', '2018-02-11'),\n            (5, '5 Log Lane',    '2009-11-19', '2020-03-15'),\n            (5, '6 Claw Close',  '2020-03-16', '2024-12-31')\n    ) AS V(EmployeeID, Address, FromDate, ToDate)\n)\n\n/* Edit this part */\nSELECT\n    Employee.EmployeeID,\n    Employee.EmployeeName,\n    Employee.DepartmentID,\n    Department.DepartmentName,\n    Address.Address,\n    Address.FromDate,\n    Address.ToDate\nFROM Employee\n    INNER JOIN Department\n        ON Employee.DepartmentID = Department.DepartmentID\n    INNER JOIN Address\n        ON Employee.EmployeeID = Address.EmployeeID\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/join/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>JOIN</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/from-transact-sql#join-type</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/xG5CqLICKcY</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/join/#additional-join-modifiers-in-other-sql-flavours","title":"Additional join modifiers in other SQL flavours","text":"<p>Microsoft SQL Server has a fairly limited number of join features, but other SQL flavours add loads of additional modifiers to the <code>JOIN</code> clause.</p> <p>If you see something that you don't recognise, make sure that you search for it in the documentation for the specific SQL flavour that you see the thing in!</p>"},{"location":"from-excel-to-sql/main-concepts/join/#visual-representation-of-joins","title":"Visual representation of joins","text":"<p>If you're a visual learner, you might find it helpful to read the following article from Atlassian (the company behind Jira and Confluence) which has some great visual representations of the different join types:</p> <ul> <li>https://www.atlassian.com/data/sql/sql-join-types-explained-visually</li> </ul> <p>For example, their \"cheat sheet\" is:</p> <p></p>"},{"location":"from-excel-to-sql/main-concepts/logical-processing-order/","title":"Logical processing order \ud83c\udfa5","text":"<p>Warning</p> <p>Confusingly, the order in which things are done in a <code>SELECT</code> statement is not exactly the same as the order in which they are written.</p> <p>This is because SQL code was designed to be written in a way that is easy to read and write, rather than to reflect what happens under the hood.</p>"},{"location":"from-excel-to-sql/main-concepts/logical-processing-order/#the-written-order-of-a-select-statement","title":"The written order of a <code>SELECT</code> statement","text":"<p>This has been mentioned in each of the clauses' respective pages, but the lexical (written) order of a <code>SELECT</code> statement is as follows:</p> <ol> <li><code>SELECT</code></li> <li><code>DISTINCT</code></li> <li><code>TOP</code></li> <li><code>FROM</code></li> <li><code>JOIN</code></li> <li><code>ON</code></li> <li><code>WHERE</code></li> <li><code>GROUP BY</code></li> <li><code>WITH CUBE</code> or <code>WITH ROLLUP</code></li> <li><code>HAVING</code></li> <li><code>WINDOW</code></li> <li><code>ORDER BY</code></li> </ol>"},{"location":"from-excel-to-sql/main-concepts/logical-processing-order/#the-logical-processing-order-of-a-select-statement","title":"The logical processing order of a <code>SELECT</code> statement","text":"<p>The logical processing order of a <code>SELECT</code> statement is not the same as the written order.</p> <p>A big part of understanding SQL is understanding the order in which things are done in a <code>SELECT</code> statement.</p> <p>Do joins happen before or after the <code>WHERE</code> clause? Are rows deduplicated before being aggregated? Are rows ordered before being \"topped\" (with <code>TOP</code>)?</p> <p>This is important to understand because it can affect the result of your query.</p> <p>As per the Microsoft SQL Server documentation, the logical processing order of a <code>SELECT</code> statement is as follows:</p> <ol> <li><code>FROM</code></li> <li><code>ON</code></li> <li><code>JOIN</code></li> <li><code>WHERE</code></li> <li><code>GROUP BY</code></li> <li><code>WITH CUBE</code> or <code>WITH ROLLUP</code></li> <li><code>HAVING</code></li> <li><code>SELECT</code> (and <code>OVER</code>/<code>WINDOW</code>)</li> <li><code>DISTINCT</code></li> <li><code>ORDER BY</code></li> <li><code>TOP</code></li> </ol> <p>SQL has this disparity between the written code and the order in which it is processed because SQL is a \"declarative\" language. You don't need to know what this means, but it's just a fancy way of saying that you tell SQL what you want, not how to get it.</p>"},{"location":"from-excel-to-sql/main-concepts/logical-processing-order/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the logical processing order of the select statement at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql#logical-processing-order-of-the-select-statement</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/operators/","title":"Operators \u2795","text":"<p>Success</p> <p>Like we saw in the Filtering section, the SQL \"operators\" are very similar to the Excel operators.</p>"},{"location":"from-excel-to-sql/main-concepts/operators/#sql-has-the-same-operators-as-excel","title":"SQL has the same operators as Excel","text":"<p>We saw in the Filtering section that SQL has the comparison operators that we're familiar with from Excel:</p> <ul> <li><code>&lt;</code> (less than)</li> <li><code>&lt;=</code> (less than or equal to)</li> <li><code>&gt;</code> (greater than)</li> <li><code>&gt;=</code> (greater than or equal to)</li> <li><code>=</code> (equals)</li> <li><code>&lt;&gt;</code> (does not equal), also written as <code>!=</code></li> </ul> <p>Unsurprisingly, SQL also has the same arithmetic operators that we're familiar with from Excel:</p> <ul> <li><code>+</code> (addition)</li> <li><code>-</code> (subtraction)</li> <li><code>*</code> (multiplication)</li> <li><code>/</code> (division)</li> </ul> <p>We'd use these exactly as you'd expect:</p> <pre><code>SELECT\n    1 + 1 AS TWO,\n    2 - 1 AS ONE,\n    2 * 2 AS FOUR,\n    6 / 2 AS THREE\n;\n</code></pre> TWO ONE FOUR THREE 2 1 4 3"},{"location":"from-excel-to-sql/main-concepts/operators/#unlike-excel-be-careful-with-division","title":"Unlike Excel, be careful with division!","text":"<p>In Excel, if you divide a whole number by another whole number, Excel will give you what you expect -- for example, <code>5 / 2</code> will give you <code>2.5</code>.</p> <p>In SQL, if you divide a whole number by another whole number, you'll get a whole number back. This means that <code>5 / 2</code> will give you <code>2</code>, not <code>2.5</code>!</p> <pre><code>SELECT 5 / 2 AS FIVE_DIVIDED_BY_TWO;\n</code></pre> FIVE_DIVIDED_BY_TWO 2 <p>This is because of what we covered in the Data types section; SQL (at least, Microsoft SQL Server) is more pedantic with data types than Excel is.</p> <p>The natural question is, \"how do we get the correct number back?\"</p> <p>There are a few things that we could do that you'll see out in the wild:</p> <ul> <li>If you specify the numbers, add a decimal point to (at least) one of them</li> <li>If you're using columns, cast (at least) one column to a <code>DECIMAL</code> or <code>FLOAT</code> data type</li> <li>If you're using columns, multiply by <code>1.0</code> to convert the whole number to a decimal (this is a \"cheat\" way of doing the previous point)</li> </ul> <p>The following are all how we'd implement the points above:</p> <pre><code>SELECT\n    5.0 / 2 AS OPTION_1,\n    CAST(5 AS DECIMAL) / 2 AS OPTION_2,\n    1.0 * 5 / 2 AS OPTION_3\n;\n</code></pre> OPTION_1 OPTION_2 OPTION_3 2.500000 2.500000 2.500000 <p>Warning</p> <p>It's important to do the data type conversion before the division. For example, the following would not give you the correct answer:</p> <pre><code>SELECT CAST(5 / 2 AS DECIMAL) AS INCORRECT;\n</code></pre> <p>This is because the division will be done before the conversion, so the damage will have already been done!</p>"},{"location":"from-excel-to-sql/main-concepts/operators/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on operators at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/operators-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/bxZeIkcxYQA</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/order-by/","title":"Ordering \u23ec","text":"<p>Success</p> <p>The <code>ORDER BY</code> clause is used to sort the rows in a query. It's like the \"Sort by\" feature in Excel!</p> <p>Note</p> <p>The <code>ORDER BY</code> clause is optional. If you use it, it must come at the end of the SQL statement.</p>"},{"location":"from-excel-to-sql/main-concepts/order-by/#order-by-is-how-we-sort-rows","title":"<code>ORDER BY</code> is how we sort rows","text":"<p>We know how to \"open a file\" using <code>SELECT</code> and <code>FROM</code>, and we know how to \"filter\" rows using <code>WHERE</code>.</p> <p>To sort rows, use the <code>ORDER BY</code> clause and specify the columns that you want to order by.</p> <p>In Excel, there are two ways to sort data:</p> <ol> <li>Click on the column header and use the \"Sort A to Z\" or \"Sort Z to A\" buttons.</li> <li>Use the \"Sort\" feature in the \"Data\" tab.</li> </ol> <p>Sorting in SQL is more like the second option, where you can specify the columns to sort by and the direction to sort in (ascending or descending).</p> <p>For example, we could sort the <code>HumanResources.Department</code> table by the <code>Name</code> column in ascending order using:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nORDER BY Name\n;\n</code></pre> DepartmentID Name GroupName 12 Document Control Quality Assurance 1 Engineering Research and Development 16 Executive Executive General and Administration 14 Facilities and Maintenance Executive General and Administration 10 Finance Executive General and Administration <p>Tip</p> <p>The <code>ORDER BY</code> clause \"sounds like\" English, so the query above can be read as:</p> <p>\"Select the department ID, name, and group name from the <code>HumanResources.Department</code> table and order by the name\".</p> <p>To sort in descending order, use the <code>DESC</code> keyword:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nORDER BY Name DESC\n;\n</code></pre> DepartmentID Name GroupName 2 Tool Design Research and Development 15 Shipping and Receiving Inventory Management 3 Sales Sales and Marketing 6 Research and Development Research and Development 13 Quality Assurance Quality Assurance <p>To sort by multiple columns, separate the columns with a comma:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nORDER BY GroupName, DepartmentID\n;\n</code></pre> DepartmentID Name GroupName 9 Human Resources Executive General and Administration 10 Finance Executive General and Administration 11 Information Services Executive General and Administration 14 Facilities and Maintenance Executive General and Administration 16 Executive Executive General and Administration <p>Warning</p> <p>If the <code>ORDER BY</code> tries to sort repeated values, the order of the rows is not guaranteed. If you need to guarantee the order of the rows, make sure you include enough columns in the <code>ORDER BY</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/order-by/#you-can-use-the-column-alias-in-the-order-by-clause","title":"You can use the column alias in the <code>ORDER BY</code> clause","text":"<p>Info</p> <p>The <code>ORDER BY</code> clause is one of the few places where this works; it doesn't work in most other places (in Microsoft SQL Server).</p> <p>If you rename/use an alias for a column in the <code>SELECT</code> clause, you can use that alias in the <code>ORDER BY</code> clause. For example:</p> <pre><code>SELECT\n    DepartmentID AS ID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nORDER BY GroupName, ID\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/order-by/#you-can-sort-by-column-numbers-but-dont","title":"You can sort by column numbers, but don't","text":"<p>Info</p> <p>This is just a FYI in case you see this out in the wild.</p> <p>Instead of using the column names in the <code>ORDER BY</code> clause, you can use their position in the query (starting at 1). For example, the following query sorts the <code>HumanResources.Department</code> table by the <code>GroupName</code> column:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nORDER BY 3\n;\n</code></pre> <p>Although this is possible, it's not recommended (as per the Microsoft documentation):</p> <p>Avoid specifying integers in the ORDER BY clause as positional representations of the columns in the select list. For example, although a statement such as <code>SELECT ProductID, Name FROM Production.Production ORDER BY 2</code> is valid, the statement is not as easily understood by others compared with specifying the actual column name. In addition, changes to the select list, such as changing the column order or adding new columns, requires modifying the ORDER BY clause in order to avoid unexpected results.</p>"},{"location":"from-excel-to-sql/main-concepts/order-by/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>ORDER BY</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/yaomCldxZi4</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/order-by/#additional-modifiers","title":"Additional modifiers","text":"<p>The <code>ORDER BY</code> clause also has additional modifiers which are outside the scope of this course. These include <code>COLLATE</code>, <code>OFFSET</code>, and <code>FETCH</code>:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql#Collation</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-order-by-clause-transact-sql#using-offset-and-fetch-to-limit-the-rows-returned</li> </ul> <p>Danger</p> <p>This is a contrived example to show the additional modifiers.</p> <pre><code>SELECT\n   DepartmentID,\n   Name,\n   GroupName\nFROM HumanResources.Department\nORDER BY DepartmentID\n OFFSET 10 ROWS\n FETCH NEXT 5 ROWS ONLY\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/rollup/","title":"Pivot tables \ud83e\uddee","text":"<p>Success</p> <p>One of Excel's most awesome features is pivot tables -- and SQL has them, too (at least, most flavours)!</p> <p>Note</p> <p>The <code>ROLLUP</code> modifier is optional. If you use it, it must be part of the <code>GROUP BY</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/rollup/#we-use-the-rollup-modifier-to-create-pivot-tables","title":"We use the <code>ROLLUP</code> modifier to create \"pivot tables\"","text":"<p>In the aggregations section, we saw that we can use the <code>GROUP BY</code> clause to group rows together and summarise them.</p> <p>This is handy but, unlike Excel's pivot tables, it doesn't include subtotals and grand totals.</p> <p>To tell SQL to include these totals, we use the <code>ROLLUP</code> modifier! This modifier goes immediately after the <code>GROUP BY</code> text, and the grouping columns are listed in brackets.</p> <p>For example, consider the following query which produces six months of sales summaries:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY FORMAT(OrderDate, 'yyyy-MM')\nORDER BY OrderMonth\n;\n</code></pre> OrderMonth TotalSales 2013-01 2340061.5521 2013-02 2600218.8667 2013-03 3831605.9389 2013-04 2840711.1734 2013-05 3658084.9461 2013-06 5726265.2635 <p>We could use <code>ROLLUP</code> to add a grand total to the results:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY ROLLUP (FORMAT(OrderDate, 'yyyy-MM'))\nORDER BY OrderMonth\n;\n</code></pre> OrderMonth TotalSales null 20996947.7407 2013-01 2340061.5521 2013-02 2600218.8667 2013-03 3831605.9389 2013-04 2840711.1734 2013-05 3658084.9461 2013-06 5726265.2635 <p>Note that the <code>OrderMonth</code> column now includes a <code>NULL</code> value, which represents the grand total.</p> <p>This query only groups by a single column, so there are no subtotals (only the grand total). If we were to group by multiple columns, we would see subtotals for each combination of the grouping columns.</p> <p>For example, we could extend the example above (without the <code>ROLLUP</code> modifier) to also group by the <code>OnlineOrderFlag</code> column:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> OrderMonth OnlineOrderFlag TotalSales 2013-01 false 1761132.8322 2013-01 true 578928.7199 2013-02 false 2101152.5476 2013-02 true 499066.3191 2013-03 false 3244501.4287 2013-03 true 587104.5102 2013-04 false 2239156.6675 2013-04 true 601554.5059 2013-05 false 3019173.6253 2013-05 true 638911.3208 2013-06 false 4775809.3027 2013-06 true 950455.9608 <p>Adding the <code>ROLLUP</code> modifier to the <code>GROUP BY</code> clause will add subtotals for the order months and a grand total:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    OnlineOrderFlag,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY ROLLUP (\n    FORMAT(OrderDate, 'yyyy-MM'),\n    OnlineOrderFlag\n)\nORDER BY\n    OrderMonth,\n    OnlineOrderFlag\n;\n</code></pre> OrderMonth OnlineOrderFlag TotalSales null null 20996947.7407 2013-01 null 2340061.5521 2013-01 false 1761132.8322 2013-01 true 578928.7199 2013-02 null 2600218.8667 2013-02 false 2101152.5476 2013-02 true 499066.3191 2013-03 null 3831605.9389 2013-03 false 3244501.4287 2013-03 true 587104.5102 2013-04 null 2840711.1734 2013-04 false 2239156.6675 2013-04 true 601554.5059 2013-05 null 3658084.9461 2013-05 false 3019173.6253 2013-05 true 638911.3208 2013-06 null 5726265.2635 2013-06 false 4775809.3027 2013-06 true 950455.9608 <p>Warning</p> <p>Did you notice that there were subtotals for the order months, but no subtotals for the <code>OnlineOrderFlag</code> column? This is because, like with Excel's pivot tables, the order of the columns is significant!</p> <p>If we switched the order of the columns in the <code>GROUP BY</code> clause, the subtotals for <code>OnlineOrderFlag</code> would be calculated but not the subtotals for the order months.</p> <p>The subtotals that are generated follow the same rules as Excel's pivot tables.</p> <p>Success</p> <p>SQL has called this modifier \"rollup\" because it rolls up the values into subtotals and grand totals!</p>"},{"location":"from-excel-to-sql/main-concepts/rollup/#theres-an-alternative-syntax-with-rollup","title":"There's an alternative syntax: <code>WITH ROLLUP</code>","text":"<p>Instead of specifying <code>ROLLUP</code> immediately after the <code>GROUP BY</code> text and listing the grouping columns in brackets, we could instead just add the text <code>WITH ROLLUP</code> after the list of columns:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY FORMAT(OrderDate, 'yyyy-MM') WITH ROLLUP\nORDER BY OrderMonth\n;\n</code></pre> <p>Although this syntax is supported, it's not the standard syntax to use and is only included for backwards compatibility.</p> <p>You should stick to the standard syntax of adding <code>ROLLUP</code> immediately after the <code>GROUP BY</code> text and listing the grouping columns in brackets.</p>"},{"location":"from-excel-to-sql/main-concepts/rollup/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on <code>ROLLUP</code> at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-group-by-transact-sql#group-by-rollup</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/65EFEtjYL9E</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/rollup/#additional-grouping-functions","title":"Additional grouping functions","text":"<p>There are additional functions which are outside the scope of this course to distinguish between <code>NULL</code> values generated by the subtotals/grand totals and <code>NULL</code> values that are in the original data.</p> <p>They are the <code>GROUPING</code> and <code>GROUPING_ID</code> functions which help identify which rows correspond to different levels of the <code>ROLLUP</code> hierarchy:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/grouping-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/grouping-id-transact-sql</li> </ul> <p>Danger</p> <p>This is a contrived example to show the additional grouping functions.</p> <pre><code>SELECT\n   GROUPING(FORMAT(OrderDate, 'yyyy-MM')) AS IsOrderDateSubtotal,\n   GROUPING(OnlineOrderFlag) AS IsOnlineOrderFlagSubtotal,\n   GROUPING_ID(FORMAT(OrderDate, 'yyyy-MM'), OnlineOrderFlag) AS GroupingId,\n\n   FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n   OnlineOrderFlag,\n   SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE '2013-01-01' &lt;= OrderDate AND OrderDate &lt; '2013-07-01'\nGROUP BY ROLLUP (\n   FORMAT(OrderDate, 'yyyy-MM'),\n   OnlineOrderFlag\n)\nORDER BY\n   OrderMonth,\n   OnlineOrderFlag\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/select-and-from/","title":"Gimme data \ud83d\udcc1","text":"<p>Success</p> <p>Now you know that SQL is a language for getting data from a database, let's actually get some data!</p> <p>Note</p> <p>From here on, we'll be using a Microsoft SQL Server database filled with the AdventureWorks data. If you want to follow along, you can use the dbfiddle site to run the queries against the same data:</p> <ul> <li>https://dbfiddle.uk/rKIFRoNm</li> </ul> <p>Alternatively, follow the instructions linked in the homepage:</p> <ul> <li>Introduction to SQL Programming for Excel Users - SQL Server Windows Setup</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#select-and-from-are-how-you-open-a-file","title":"<code>SELECT</code> and <code>FROM</code> are how you \"open a file\"","text":"<p>If you wanted to get some data from an Excel file, you'd navigate through your folders, open the file, and then click on the sheet that has the data you want.</p> <p>To do the same thing in SQL, we need to write the <code>SELECT</code> and <code>FROM</code> clauses:</p> <ul> <li><code>SELECT</code> tells the database that we want to see some data</li> <li><code>FROM</code> tells the database where to get the data from</li> </ul> <p>Although your Excel file might live inside nested folders, SQL databases are a bit more structured.</p> <p>For the most part, there's only one depth of \"folders\" which we call the schema.</p> <p>The AdventureWorks database has several of these folders/schemas, which each contains tables. The folders/schemas in the AdventureWorks database are:</p> <ul> <li><code>dbo</code> (this is a special folder/schema which you can ignore for now)</li> <li><code>HumanResources</code></li> <li><code>Person</code></li> <li><code>Production</code></li> <li><code>Purchasing</code></li> <li><code>Sales</code></li> </ul> <p>Each of these folders/schemas contains a bunch of tables, and we will need to specify both the folder/schema and the table in the <code>FROM</code> clause.</p> <p>For example, the <code>HumanResources</code> folder/schema contains a <code>Department</code> table, so we would write <code>HumanResources.Department</code> in the <code>FROM</code> clause to \"open that file\":</p> <pre><code>SELECT DepartmentID, Name\nFROM HumanResources.Department\n;\n</code></pre> <p>Writing the query is the first part -- to actually get some data, we then need to run the query!</p> <p>The first few rows from the result of this query are:</p> DepartmentID Name 12 Document Control 1 Engineering 16 Executive 14 Facilities and Maintenance 10 Finance <p>Tip</p> <p>Remember that SQL \"sounds like\" English, so the query above can be read as:</p> <p>\"Select the department ID and name from the <code>HumanResources.Department</code> table\".</p> <p>Note</p> <p>The <code>FROM</code> clause always comes after the <code>SELECT</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#specify-or-column-names-in-the-select-clause","title":"Specify <code>*</code> or column names in the <code>SELECT</code> clause","text":"<p>The <code>HumanResources.Department</code> table has a bunch of columns, but we only asked for two of them in the <code>SELECT</code> clause.</p> <p>To see more columns, we would just add them to the <code>SELECT</code> clause:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName,\n    ModifiedDate\nFROM HumanResources.Department\n;\n</code></pre> DepartmentID Name GroupName ModifiedDate 1 Engineering Research and Development 2008-04-30 00:00:00.000 2 Tool Design Research and Development 2008-04-30 00:00:00.000 3 Sales Sales and Marketing 2008-04-30 00:00:00.000 4 Marketing Sales and Marketing 2008-04-30 00:00:00.000 5 Purchasing Inventory Management 2008-04-30 00:00:00.000 <p>To see all the columns without listing them all explicitly, we can use the <code>*</code> character in the <code>SELECT</code> clause. The <code>*</code> character is a wildcard that means \"all columns\":</p> <pre><code>SELECT *\nFROM HumanResources.Department\n;\n</code></pre> <p>Tip</p> <p>We read <code>*</code> as \"all columns\" or \"everything\", so the query above can be read as:</p> <p>\"Select all columns from the <code>HumanResources.Department</code> table\".</p> <p>Since this table only has the 4 columns that we used previously, the result is the same as the previous query!</p> <ul> <li>\u2705 The advantage of using the <code>*</code> character is that you don't need to know the names of the columns in the table</li> <li>\u274c The disadvantage is that you might get more columns than you need, which can make the result harder to read and use.</li> </ul> <p>When you write SQL, it's up to you whether you use the <code>*</code> character or list the columns explicitly. There are some best practices depending on the situation, but they won't be covered in this course.</p> <p>Note that you can also specify the same column multiple times in the <code>SELECT</code> clause if you want. The example below is a silly one to prove this, but we'll see more practical examples later:</p> <pre><code>SELECT\n    DepartmentID,\n    DepartmentID,\n    DepartmentID\nFROM HumanResources.Department\n;\n</code></pre> DepartmentID DepartmentID DepartmentID 12 12 12 1 1 1 16 16 16 14 14 14 10 10 10"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#use-as-to-rename-columns","title":"Use <code>AS</code> to \"rename\" columns","text":"<p>The <code>AS</code> keyword is used to rename/alias columns in the <code>SELECT</code> clause. Just write <code>AS</code> followed by the new name that you want to give the column:</p> <pre><code>SELECT\n    DepartmentID AS ID,\n    Name\nFROM HumanResources.Department\n;\n</code></pre> ID Name 12 Document Control 1 Engineering 16 Executive 14 Facilities and Maintenance 10 Finance <p>The <code>AS</code> keyword should also be used after any calculations to give the calculated column a name. We'll see examples of this later.</p> <p>Tip</p> <p>The <code>AS</code> keyword continues to \"sound like\" English -- the query above can be read as:</p> <p>\"Select the department ID as id and the name from the <code>HumanResources.Department</code> table\".</p> <p>Info</p> <p>The <code>AS</code> keyword is optional when you're renaming columns, but it's a good idea to use it for clarity. It's clearer and easier to read <code>DepartmentID AS ID</code> than <code>DepartmentID ID</code>!</p>"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#from-is-optional","title":"<code>FROM</code> is optional","text":"<p>Tip</p> <p>The <code>FROM</code> clause is only required when you're getting data from a table. If you're not getting data from a table, you can leave it out.</p> <p>Although you would use the <code>FROM</code> clause in most situations, it's worth knowing that it's optional. If you write <code>SELECT</code> without a <code>FROM</code> clause, the SQL will return a single row with the value(s) that you specify:</p> <pre><code>SELECT\n    'This is some text' AS SOME_TEXT,\n    123 AS SOME_NUMBER\n;\n</code></pre> SOME_TEXT SOME_NUMBER This is some text 123"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#you-can-use-the-information_schema-to-see-whats-in-the-database","title":"You can use the <code>INFORMATION_SCHEMA</code> to see what's in the database","text":"<p>Warning</p> <p>This is slightly more advanced, but it's a useful trick to know about.</p> <p>The hardest part about SQL compared to Excel is that you can't just click around to see what's available -- when you write a query, you need to know what's in the database.</p> <p>However, most databases hold some special default tables that keep track of what's in the database. The <code>INFORMATION_SCHEMA</code> is a special folder/schema that holds these tables.</p> <p>To see the tables in the database, you can check the <code>TABLES</code> table in the <code>INFORMATION_SCHEMA</code>:</p> <pre><code>SELECT TABLE_SCHEMA, TABLE_NAME\nFROM INFORMATION_SCHEMA.TABLES\n;\n</code></pre> TABLE_SCHEMA TABLE_NAME Sales SalesTaxRate Sales PersonCreditCard Person vAdditionalContactInfo Person PersonPhone HumanResources vEmployee <p>To see the columns in the tables, you can check the <code>COLUMNS</code> table in the <code>INFORMATION_SCHEMA</code>:</p> <pre><code>SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME\nFROM INFORMATION_SCHEMA.COLUMNS\n;\n</code></pre> TABLE_SCHEMA TABLE_NAME COLUMN_NAME Sales PersonCreditCard BusinessEntityID Sales PersonCreditCard CreditCardID Sales PersonCreditCard ModifiedDate Person vAdditionalContactInfo BusinessEntityID Person vAdditionalContactInfo City Person vAdditionalContactInfo CountryRegion <p>Tip</p> <p>When you first start using a new database, you might find these queries useful to see what's available.</p> <p>The Microsoft SQL Server documentation for this <code>INFORMATION_SCHEMA</code> folder/schema is available at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/relational-databases/system-information-schema-views/system-information-schema-views-transact-sql</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/select-and-from/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>SELECT</code> and <code>FROM</code> clauses at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-clause-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-examples-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/ZbzYKMHKvdw</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/style-guide/","title":"Style guide \u2728","text":"<p>Success</p> <p>Although SQL is super flexible in how you write it, it's a good idea to stick to a consistent style.</p> <p>This makes it easier for others to read your code which is especially important when you're working in a team or when you're sharing your code with others.</p>"},{"location":"from-excel-to-sql/main-concepts/style-guide/#sql-style-is-a-contentious-topic","title":"SQL style is a contentious topic...","text":"<p>Anyone who has written SQL for a little while will find the style that they like, and they'll typically want to stick to it (for better or worse) \ud83d\ude1d</p> <p>There are plenty of conflicting styles out there, so this guide is just to recommend the style for things that most people agree on.</p>"},{"location":"from-excel-to-sql/main-concepts/style-guide/#some-general-rules","title":"Some general rules","text":""},{"location":"from-excel-to-sql/main-concepts/style-guide/#use-consistent-capitalisation","title":"Use consistent capitalisation","text":"<p>The capitalisation that you use for your column names and table names should match their case in the database.</p> <p>For example, the AdventureWorks database uses Pascal case for its table names, so you should use Pascal case in your SQL:</p> <pre><code>/* Good */\nSELECT FirstName, LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt; 5\n;\n\n/* Bad */\nSELECT firstName, LASTNAME\nFROM person.PERSON\nWHERE businessentityid &lt; 5\n;\n</code></pre> <p>The capitalisation that you use for your SQL keywords (e.g. <code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>) should be consistent, and should match the standards of your team (if you have one).</p> <pre><code>/* Good, if your team use uppercase */\nSELECT FirstName, LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt; 5\n;\n\n/* Good, if your team use lowercase */\nselect FirstName, LastName\nfrom Person.Person\nwhere BusinessEntityID &lt; 5\n;\n\n/* Bad */\nSELECT FirstName, LastName\nfrom Person.Person\nWhEre BusinessEntityID &lt; 5\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/style-guide/#put-new-clauses-on-new-lines","title":"Put new clauses on new lines","text":"<p>The main clauses (e.g. <code>SELECT</code>, <code>FROM</code>, <code>WHERE</code>) should be on new lines:</p> <pre><code>/* Good */\nSELECT FirstName, LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt; 5\n;\n\n/* Bad */\nSELECT FirstName, LastName FROM\nPerson.Person WHERE\nBusinessEntityID &lt; 5;\n\n/* Bad */\nSELECT FirstName, LastName FROM Person.Person WHERE BusinessEntityID &lt; 5;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/style-guide/#put-lists-on-indented-new-lines","title":"Put lists on indented new lines","text":"<p>For long lists of items (the length of \"long\" is contentious), put each item on a new line and indent it:</p> <pre><code>/* Good */\nSELECT\n    BusinessEntityID,\n    PersonType,\n    Title,\n    FirstName,\n    MiddleName,\n    LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt; 20\n  AND PersonType = 'EM'\n  AND MiddleName IS NOT NULL\n  AND EmailPromotion = 2\n;\n\n/* Bad */\nSELECT BusinessEntityID, PersonType, Title, FirstName, MiddleName, LastName\nFROM Person.Person\nWHERE BusinessEntityID &lt; 20 AND PersonType = 'EM' AND MiddleName IS NOT NULL AND EmailPromotion = 2\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/style-guide/#further-reading","title":"Further reading","text":"<p>There are several publicly available style guides for SQL. It's worth having a look at a few of them to see what you like and what you don't like:</p> <ul> <li>https://handbook.gitlab.com/handbook/business-technology/data-team/platform/sql-style-guide/</li> <li>https://docs.telemetry.mozilla.org/concepts/sql_style</li> <li>https://www.sqlstyle.guide/</li> </ul> <p>Once you're up to speed with SQL and looking to integrate some additional tools, you might want to check out SQLFluff which is a tool that will reformat your SQL into a consistent style for you:</p> <ul> <li>https://sqlfluff.com/</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/subqueries/","title":"Subqueries \ud83e\udde9","text":"<p>Success</p> <p>Subqueries are undoubtedly one of the most powerful features in SQL -- but with great power comes great responsibility.</p> <p>Warning</p> <p>Excel doesn't really have an equivalent to subqueries (without using advanced Excel features). Be warned that this therefore may be a bit tricky to get used to!</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#subqueries-are-nested-queries","title":"Subqueries are \"nested\" queries","text":"<p>Subqueries are one of the awesome things about SQL. They are queries \"nested\" within other queries.</p> <p>This allows you to do some pretty cool things, but is also easy to abuse! Make sure you don't go overboard with subqueries.</p> <p>The most common place to use a subquery is in the <code>FROM</code> clause to use the output of another query as if it were a table:</p> <pre><code>SELECT *\nFROM (\n    SELECT\n        BusinessEntityID AS ID,\n        FirstName AS Forename,\n        LastName AS Surname\n    FROM Person.Person\n    WHERE BusinessEntityID &lt;= 5\n) AS People\nWHERE Forename IN ('Ken', 'Rob')\n;\n</code></pre> ID Forename Surname 1 Ken S\u00e1nchez 4 Rob Walters <p>In the example above, the subquery is the query inside the parentheses. This subquery is used as if it were a table in the main/outer query.</p> <p>To help understand the example, you first need to know what the output of the subquery is:</p> <pre><code>SELECT\n    BusinessEntityID AS ID,\n    FirstName AS Forename,\n    LastName AS Surname\nFROM Person.Person\nWHERE BusinessEntityID &lt;= 5\n;\n</code></pre> ID Forename Surname 1 Ken S\u00e1nchez 2 Terri Duffy 3 Roberto Tamburello 4 Rob Walters 5 Gail Erickson <p>When we use this in the <code>FROM</code> clause, we're pretending that it's like a table that already exists -- just this table only has five rows, and the columns are called <code>ID</code>, <code>Forename</code>, and <code>Surname</code>.</p> <p>Since the subquery is used as if it were a table, we need to use the column names as they are in the subquery. This is why we use <code>Forename</code> in the outer <code>WHERE</code> clause (<code>WHERE Forename IN ('Ken', 'Rob')</code>) instead of <code>FirstName</code>.</p> <p>Note</p> <p>When you use a subquery in the <code>FROM</code> clause in Microsoft SQL Server, you need to give it an alias. This is why we have <code>AS People</code> at the end of the subquery.</p> <p>This is not the case in all SQL flavours, but it's a good habit to get into.</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#subqueries-are-good-for-using-calculated-columns","title":"Subqueries are good for using calculated columns","text":"<p>One of the reasons we like to use subqueries is to use calculated columns in places that we can't use them directly.</p> <p>We've seen that if we want to use a calculated column in places like the <code>WHERE</code> and <code>GROUP BY</code> clauses, we need to use the same calculation in the <code>SELECT</code> clause:</p> <pre><code>SELECT\n    FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE FORMAT(OrderDate, 'yyyy-MM') IN ('2013-01', '2013-02', '2013-03')\nGROUP BY FORMAT(OrderDate, 'yyyy-MM')\nORDER BY OrderMonth\n;\n</code></pre> <p>If we instead do the calculation in a subquery, we can use the calculated column in the <code>WHERE</code> and <code>GROUP BY</code> clauses without having to repeat the calculation:</p> <pre><code>SELECT\n    OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM (\n    SELECT\n        FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n        TotalDue\n    FROM Sales.SalesOrderHeader\n) AS Orders\nWHERE OrderMonth IN ('2013-01', '2013-02', '2013-03')\nGROUP BY OrderMonth\nORDER BY OrderMonth\n;\n</code></pre> <p>This isn't super helpful in the example above, but it would be in cases where the calculation is more complex.</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#subqueries-can-be-used-in-other-places-too","title":"Subqueries can be used in other places too","text":"<p>Although the most common place to use subqueries is in the <code>FROM</code> clause, they can also be used in other places like the <code>WHERE</code> and <code>SELECT</code> clauses (plus others).</p> <p>However, there are different rules for using subqueries in these places: when we use the subquery in the <code>FROM</code> clause, we return an entire table; when we use the subquery in the <code>WHERE</code> or <code>SELECT</code> clauses, we return a single value.</p> <p>We'll see advanced examples of these in the correlated subqueries section.</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#subqueries-in-the-where-clause","title":"Subqueries in the <code>WHERE</code> clause","text":"<p>A good use of a subquery in the <code>WHERE</code> clause is to check if a value meets some condition relative to the rest of the values.</p> <p>For example, the following query returns the sales orders whose total due is greater than the average total due for the table:</p> <pre><code>SELECT TOP 5\n    SalesOrderID,\n    OrderDate,\n    TotalDue\nFROM Sales.SalesOrderHeader\nWHERE TotalDue &gt; (\n    /* This produces a single value that we can compare against */\n    SELECT AVG(TotalDue)\n    FROM Sales.SalesOrderHeader\n)\n;\n</code></pre> SalesOrderID OrderDate TotalDue 43659 2011-05-31 00:00:00.000 23153.2339 43661 2011-05-31 00:00:00.000 36865.8012 43662 2011-05-31 00:00:00.000 32474.9324 43664 2011-05-31 00:00:00.000 27510.4109 43665 2011-05-31 00:00:00.000 16158.6961"},{"location":"from-excel-to-sql/main-concepts/subqueries/#subqueries-in-the-select-clause","title":"Subqueries in the <code>SELECT</code> clause","text":"<p>Similarly, we can use subqueries in the <code>SELECT</code> clause to keep track of some aggregate value for each row.</p> <p>For example, the following query returns the sales orders and the average total due for the table:</p> <pre><code>SELECT TOP 5\n    SalesOrderID,\n    OrderDate,\n    TotalDue,\n    (\n        /* This produces a single value that we can use in a column */\n        SELECT AVG(TotalDue)\n        FROM Sales.SalesOrderHeader\n    ) AS AverageTotalDue\nFROM Sales.SalesOrderHeader\n;\n</code></pre> SalesOrderID OrderDate TotalDue AverageTotalDue 43659 2011-05-31 00:00:00.000 23153.2339 3915.9951 43660 2011-05-31 00:00:00.000 1457.3288 3915.9951 43661 2011-05-31 00:00:00.000 36865.8012 3915.9951 43662 2011-05-31 00:00:00.000 32474.9324 3915.9951 43663 2011-05-31 00:00:00.000 472.3108 3915.9951 <p>Info</p> <p>We'll see another way to do this example in the window functions section, but it's good to know that subqueries can be used in this way too.</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#common-tables-expressions-ctes-are-another-flavour-of-subquery","title":"Common tables expressions (CTEs) are another flavour of subquery","text":"<p>Rather than using subqueries directly inside the <code>SELECT</code> statements, SQL allows us to save the subquery as a \"common table expression\" (CTE) and then use the CTE in the <code>SELECT</code> statements.</p> <p>To define a CTE, we use the <code>WITH</code> keyword followed by the name of the CTE and the subquery in parentheses. You can specify multiple CTEs after the <code>WITH</code> text by separating them with commas.</p> <p>For example, we saw the following query earlier:</p> <pre><code>SELECT\n    OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM (\n    SELECT\n        FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n        TotalDue\n    FROM Sales.SalesOrderHeader\n) AS Orders\nWHERE OrderMonth IN ('2013-01', '2013-02', '2013-03')\nGROUP BY OrderMonth\nORDER BY OrderMonth\n;\n</code></pre> <p>We could instead save the <code>Orders</code> subquery as a CTE and then use the CTE in the <code>FROM</code> clause:</p> <pre><code>WITH Orders AS (\n    SELECT\n        FORMAT(OrderDate, 'yyyy-MM') AS OrderMonth,\n        TotalDue\n    FROM Sales.SalesOrderHeader\n)\n\nSELECT\n    OrderMonth,\n    SUM(TotalDue) AS TotalSales\nFROM Orders\nWHERE OrderMonth IN ('2013-01', '2013-02', '2013-03')\nGROUP BY OrderMonth\nORDER BY OrderMonth\n;\n</code></pre> <p>Tip</p> <p>In general, using CTEs (versus using subqueries directly) is a good habit to get into as it makes your queries easier to read and understand.</p> <p>Warning</p> <p>Subqueries defined as CTEs are always treated as if they were tables, so although it was an easy \"lift-and-shift\" for the subquery in the <code>FROM</code> clause, it wouldn't be as simple for subqueries in the <code>WHERE</code> and <code>SELECT</code> clauses.</p>"},{"location":"from-excel-to-sql/main-concepts/subqueries/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on subqueries at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/relational-databases/performance/subqueries</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/pcD_7n7zKFw</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/","title":"<code>TOP</code> and <code>DISTINCT</code> \ud83d\udd1d","text":"<p>Success</p> <p>The <code>TOP</code> and <code>DISTINCT</code> keywords are handy modifiers to use after <code>SELECT</code>.</p> <p>Note</p> <p><code>TOP</code> and <code>DISTINCT</code> should be used immediately after the <code>SELECT</code> keyword.</p>"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#top-will-limit-the-number-of-rows-returned","title":"<code>TOP</code> will limit the number of rows returned","text":"<p>The <code>TOP</code> keyword is used to limit the number of rows returned from a <code>SELECT</code> statement. This is particularly useful when you're only interested in the first few rows of a result.</p> <pre><code>SELECT TOP 5\n    DepartmentID,\n    Name\nFROM HumanResources.Department\n;\n</code></pre> DepartmentID Name 12 Document Control 1 Engineering 16 Executive 14 Facilities and Maintenance 10 Finance <p>If you use <code>TOP</code> with an <code>ORDER BY</code> clause, the rows will be ordered first and then the <code>TOP</code> will be applied:</p> <pre><code>SELECT TOP 5\n    DepartmentID,\n    Name\nFROM HumanResources.Department\nORDER BY DepartmentID\n;\n</code></pre> DepartmentID Name 1 Engineering 2 Tool Design 3 Sales 4 Marketing 5 Purchasing"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#other-sql-flavours-might-use-limit-instead-of-top","title":"Other SQL flavours might use <code>LIMIT</code> instead of <code>TOP</code>","text":"<p>This is just an FYI! Although Microsoft SQL Server (and a few other SQL flavours) use <code>TOP</code>, other SQL flavours use the keyword <code>LIMIT</code> instead. Flavours that use <code>LIMIT</code> also put it at the end of the statement instead of after the <code>SELECT</code> clause, too, like this:</p> <pre><code>SELECT\n    DepartmentID,\n    Name\nFROM HumanResources.Department\nORDER BY DepartmentID\nLIMIT 5\n;\n</code></pre> <p>Make sure you know which SQL flavour you're using so that you can use the right keyword!</p>"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#distinct-will-remove-duplicate-rows-from-the-result","title":"<code>DISTINCT</code> will remove duplicate rows from the result","text":"<p>Success</p> <p><code>DISTINCT</code> is equivalent to using the \"Remove Duplicates\" feature in Excel!</p> <p>The <code>DISTINCT</code> keyword can take a bit of getting used to, but it is used to remove duplicate rows from the result. Note that \"duplicate\" means every value in the row is the same as the corresponding value in another row.</p> <p>For example, this output has rows that are the same:</p> <pre><code>SELECT\n    GroupName,\n    ModifiedDate\nFROM HumanResources.Department\nWHERE GroupName = 'Research and Development'\n;\n</code></pre> GroupName ModifiedDate Research and Development 2008-04-30 00:00:00.000 Research and Development 2008-04-30 00:00:00.000 Research and Development 2008-04-30 00:00:00.000 <p>Adding <code>DISTINCT</code> will remove the duplicates, keeping only the unique rows:</p> <pre><code>SELECT DISTINCT\n    GroupName,\n    ModifiedDate\nFROM HumanResources.Department\nWHERE GroupName = 'Research and Development'\n;\n</code></pre> GroupName ModifiedDate Research and Development 2008-04-30 00:00:00.000 <p>This keyword is particularly useful when you're interested in the unique values of a column, such as:</p> <pre><code>SELECT DISTINCT GroupName\nFROM HumanResources.Department\n;\n</code></pre> GroupName Executive General and Administration Inventory Management Manufacturing Quality Assurance Research and Development Sales and Marketing"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#top-and-distinct-can-be-used-together","title":"<code>TOP</code> and <code>DISTINCT</code> can be used together","text":"<p>Although it might not be super helpful, you can use <code>TOP</code> and <code>DISTINCT</code> together to get the first few unique rows from a result:</p> <pre><code>SELECT DISTINCT TOP 3\n    GroupName,\n    ModifiedDate\nFROM HumanResources.Department\n;\n</code></pre> GroupName ModifiedDate Executive General and Administration 2008-04-30 00:00:00.000 Inventory Management 2008-04-30 00:00:00.000 Manufacturing 2008-04-30 00:00:00.000 <p>The keyword order is important here -- <code>DISTINCT</code> has to be written before <code>TOP</code>.</p>"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on <code>TOP</code> and <code>DISTINCT</code> at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/top-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-transact-sql#c-using-distinct-with-select</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/-0M-kEkoDqw</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/top-and-distinct/#additional-modifiers","title":"Additional modifiers","text":"<p>The <code>TOP</code> keyword also has additional modifiers which are outside the scope of this course. These include <code>PERCENT</code>, <code>WITH TIES</code>, and using an expression rather than a fixed number:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/top-transact-sql#c-specifying-a-percentage</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/top-transact-sql#a-using-with-ties-to-include-rows-that-match-the-values-in-the-last-row</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/top-transact-sql#arguments</li> </ul> <p>Danger</p> <p>This is a contrived example (using a larger table) to show the additional modifiers.</p> <pre><code>SELECT TOP (10 * RAND()) PERCENT WITH TIES\n   FirstName,\n   LastName\nFROM Person.Person\nORDER BY FirstName\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/union/","title":"Unions \ud83e\uddec","text":"<p>Success</p> <p>Like joins, unions are a way to combine data from tables, but they do it vertically instead of horizontally.</p> <p>That is, a <code>JOIN</code> adds columns to a table, while a <code>UNION</code> adds rows to a table.</p> <p>Note</p> <p>The <code>UNION</code> clause is optional. If you use it, it must be between two individual <code>SELECT</code> statements.</p> <p>This makes the <code>UNION</code> clause a bit different to what we've seen so far!</p> <p>Warning</p> <p>Excel doesn't really have an equivalent to SQL's <code>UNION</code> (without using advanced Excel features), but it's just like stacking two tables on top of each other \ud83d\ude1d</p>"},{"location":"from-excel-to-sql/main-concepts/union/#the-union-clause-also-combines-data-from-tables","title":"The <code>UNION</code> clause also combines data from tables","text":"<p>Sometimes you want to combine data from two tables, but you don't want to join them together. Instead, you want to \"stack\" the tables on top of each other.</p> <p>The <code>UNION</code> clause does this by taking the results of two <code>SELECT</code> statements and combining them into a single result.</p> <p>Since SQL tables are fairly rigid, there are two important rules that the separate <code>SELECT</code> statement must follow to be able to be combined with a <code>UNION</code> clause:</p> <ol> <li>The number of columns in each <code>SELECT</code> statement must be the same.</li> <li>The data types of the columns in each <code>SELECT</code> statement must be compatible.</li> </ol> <p>To be super clear, the <code>UNION</code> clause does not check the names of the columns in the <code>SELECT</code> statements. It only checks the number of columns and the data types of the columns, and only keeps the names from the first <code>SELECT</code> statement.</p> <p>This makes the <code>UNION</code> clause more prone to error than other clauses, but it's still a handy feature to know about.</p> <p>The following is a contrived example, but it shows how the <code>UNION</code> clause works:</p> <pre><code>    SELECT TOP 3\n        BusinessEntityID,\n        PersonType,\n        FirstName,\n        LastName\n    FROM Person.Person\n    WHERE PersonType = 'EM'\nUNION\n    SELECT TOP 3\n        BusinessEntityID,\n        PersonType,\n        FirstName,\n        LastName\n    FROM Person.Person\n    WHERE PersonType = 'SP'\n;\n</code></pre> BusinessEntityID PersonType FirstName LastName 1 EM Ken S\u00e1nchez 2 EM Terri Duffy 3 EM Roberto Tamburello 274 SP Stephen Jiang 275 SP Michael Blythe 276 SP Linda Mitchell"},{"location":"from-excel-to-sql/main-concepts/union/#union-vs-union-all","title":"<code>UNION</code> vs <code>UNION ALL</code>","text":"<p>By itself, the <code>UNION</code> clause removes duplicate rows from the combined result set just as if you had used the <code>DISTINCT</code> clause:</p> <pre><code>    SELECT 1 AS Number, 'a' AS Letter\nUNION\n    SELECT 1, 'a'\nUNION\n    SELECT 2, 'b'\nUNION\n    SELECT 2, 'c'\n;\n</code></pre> Number Letter 1 a 2 b 2 c <p>If you want to keep the duplicate rows, you can use the <code>UNION ALL</code> clause instead:</p> <pre><code>    SELECT 1 AS Number, 'a' AS Letter\nUNION ALL\n    SELECT 1, 'a'\nUNION ALL\n    SELECT 2, 'b'\nUNION ALL\n    SELECT 2, 'c'\n;\n</code></pre> Number Letter 1 a 1 a 2 b 2 c"},{"location":"from-excel-to-sql/main-concepts/union/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>UNION</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-union-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/OQSLOGelJv0</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/union/#additional-set-operators","title":"Additional set operators","text":"<p>The <code>UNION</code> clause combines the results of two <code>SELECT</code> statements into a single result set.</p> <p>There are two other set operators outside the scope of this course. They are <code>EXCEPT</code> and <code>INTERSECT</code>:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/set-operators-except-and-intersect-transact-sql</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/where/","title":"Filtering \ud83d\udea6","text":"<p>Success</p> <p>The <code>WHERE</code> clause is used to filter the rows in a query. It's like the \"filter\" feature in Excel!</p> <p>Note</p> <p>The <code>WHERE</code> clause is optional. If you use it, it must come after the <code>FROM</code> clause.</p>"},{"location":"from-excel-to-sql/main-concepts/where/#where-is-how-we-filter-rows","title":"<code>WHERE</code> is how we filter rows","text":"<p>So far, we've been able to \"open a file\" by using <code>SELECT</code> and <code>FROM</code>.</p> <p>To filter rows, use the <code>WHERE</code> clause and specify the condition that you want to filter by.</p> <p>Excel is convenient and gives us a pop-up box to select the values we want to filter by, but for SQL we have to write the condition ourselves. The way that we write the condition is similar to how we write the conditions for the <code>IF</code> function in Excel using the following operators:</p> <ul> <li><code>&lt;</code> (less than)</li> <li><code>&lt;=</code> (less than or equal to)</li> <li><code>&gt;</code> (greater than)</li> <li><code>&gt;=</code> (greater than or equal to)</li> <li><code>=</code> (equals)</li> <li><code>&lt;&gt;</code> (does not equal), also written as <code>!=</code></li> </ul> <p>For example, we could filter the <code>HumanResources.Department</code> table for people who have the first name <code>Rob</code> using:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE DepartmentID = 5\n;\n</code></pre> DepartmentID Name GroupName 5 Purchasing Inventory Management <p>Tip</p> <p>The <code>WHERE</code> clause \"sounds like\" English, so the query above can be read as:</p> <p>\"Select the department ID, name, and group name from the <code>HumanResources.Department</code> table where the department ID is 5\".</p> <p>Similarly, we could filter the <code>HumanResources.Department</code> table for departments whose ID is less than or equal to <code>5</code> using:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE DepartmentID &lt;= 5\n;\n</code></pre> DepartmentID Name GroupName 1 Engineering Research and Development 2 Tool Design Research and Development 3 Sales Sales and Marketing 4 Marketing Sales and Marketing 5 Purchasing Inventory Management"},{"location":"from-excel-to-sql/main-concepts/where/#conditions-can-be-combined-with-and-and-or","title":"Conditions can be combined with <code>AND</code> and <code>OR</code>","text":"<p>If you wanted to have multiple conditions in an <code>IF</code> statement in Excel, you'd need to use the <code>AND</code> or <code>OR</code> functions:</p> <pre><code>=IF(AND(A1 = \"Alan\", B1 &lt;= 5), \"Yes\", \"No\")\n</code></pre> <p>In SQL, <code>AND</code> and <code>OR</code> aren't functions; they're keywords that you use to combine conditions in the <code>WHERE</code> clause.</p> <p>For example, we could filter the <code>HumanResources.Department</code> table for departments whose ID is less than or equal to <code>5</code> and the department group name is <code>Research and Development</code> with:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE DepartmentID &lt;= 5 AND GroupName = 'Research and Development'\n;\n</code></pre> DepartmentID Name GroupName 1 Engineering Research and Development 2 Tool Design Research and Development <p>Tip</p> <p>Combining conditions \"sounds like\" English, so the query above can be read as:</p> <p>\"Select the department ID, name, and group name from the <code>HumanResources.Department</code> table where the department ID is less than or equal to 5 and the group name is <code>Research and Development</code>\".</p> <p>Similarly, we could filter the <code>HumanResources.Department</code> table for departments whose group name is either <code>Sales and Marketing</code> or <code>Research and Development</code> using:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE GroupName = 'Sales and Marketing' OR GroupName = 'Research and Development'\n;\n</code></pre> DepartmentID Name GroupName 1 Engineering Research and Development 2 Tool Design Research and Development 3 Sales Sales and Marketing 4 Marketing Sales and Marketing 6 Research and Development Research and Development <p>It's common to use <code>IN</code> (and <code>NOT IN</code>) to streamline multiple <code>OR</code> conditions. For example, the previous query could be written as:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE GroupName IN ('Sales and Marketing', 'Research and Development')\n;\n</code></pre> <p>Note that the <code>IN</code> keyword is followed by a list of values in brackets separated by commas.</p> <p>You can combine <code>AND</code> and <code>OR</code> in the same <code>WHERE</code> clause, but it's a good idea to use brackets to make the order of operations clear. For example, the following query filters the <code>HumanResources.Department</code> table for departments whose ID is less than or equal to <code>5</code> and the department group name is <code>Research and Development</code>, or the department group name is ``:</p> <pre><code>SELECT\n    DepartmentID,\n    Name,\n    GroupName\nFROM HumanResources.Department\nWHERE (DepartmentID &lt;= 5 AND GroupName = 'Research and Development')\n   OR DepartmentID = 10\n;\n</code></pre> DepartmentID Name GroupName 1 Engineering Research and Development 2 Tool Design Research and Development 10 Finance Executive General and Administration"},{"location":"from-excel-to-sql/main-concepts/where/#use-is-not-null-to-filter-null-values","title":"Use <code>IS</code> (<code>NOT</code>) <code>NULL</code> to filter <code>NULL</code> values","text":"<p>Warning</p> <p>We'll learn more about <code>NULL</code> values in the Data types section, but for now, we'll mention that <code>NULL</code> is a special value that you'll sometimes see in SQL which represents a missing value similar to how <code>(blank)</code> is used in Excel.</p> <p>Instead of using <code>=</code> or <code>!=</code> to filter <code>NULL</code> values, you need to use the special <code>IS NULL</code> or <code>IS NOT NULL</code> keywords.</p> <p>For example, we could filter the <code>HumanResources.EmployeeDepartmentHistory</code> table for employees whose department end date is missing using:</p> <pre><code>SELECT\n    BusinessEntityID,\n    DepartmentID,\n    StartDate,\n    EndDate\nFROM HumanResources.EmployeeDepartmentHistory\nWHERE EndDate IS NULL\n</code></pre> BusinessEntityID DepartmentID StartDate EndDate 1 16 2009-01-14 null 2 1 2008-01-31 null 3 1 2007-11-11 null 4 2 2010-05-31 null 5 1 2008-01-06 null"},{"location":"from-excel-to-sql/main-concepts/where/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>WHERE</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/where-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/g_5OxUYPx7E</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/where/#additional-comparison-operators","title":"Additional comparison operators","text":"<p>There are additional comparison operators that you can use in the <code>WHERE</code> clause which are outside the scope of this course. These include but are not limited to the <code>BETWEEN</code>, <code>LIKE</code>, and <code>EXISTS</code> operators:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/between-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/like-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/language-elements/exists-transact-sql</li> </ul> <p>Danger</p> <p>This is a contrived example to show some of the additional comparison operators.</p> <pre><code>SELECT\n   DepartmentID,\n   Name,\n   GroupName\nFROM HumanResources.Department\nWHERE DepartmentID BETWEEN 1 AND 5\n  OR GroupName NOT LIKE '%and%'\n;\n</code></pre>"},{"location":"from-excel-to-sql/main-concepts/window-functions/","title":"Window functions \ud83d\udcc8","text":"<p>Success</p> <p>Windows functions allow us to summarise rows without having to use the <code>GROUP BY</code> clause.</p> <p>There are two ways to use window functions, and we'll see that both are very similar to row aggregations that we do in Excel!</p> <p>Warning</p> <p>Window functions are widely regarded as an advanced concept in SQL. Hopefully this page will show that they're not as scary as people make them seem!</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#window-functions-are-another-way-to-summarise-rows","title":"Window functions are another way to summarise rows","text":"<p>We saw in the aggregations section that we can use the <code>GROUP BY</code> clause to summarise rows. An important result of this is that the number of rows is reduced.</p> <p>However, there are times when we want to summarise rows without reducing the number of rows; that is, without having to use <code>GROUP BY</code>.</p> <p>This is where window functions come in: they summarise rows without reducing the row count.</p> <p>There are three extremely common use cases for window functions:</p> <ul> <li>Summarising entire columns</li> <li>Calculating running totals</li> <li>Calculating moving averages</li> </ul> <p>I'll bet you've done these in Excel before! \ud83d\ude1d</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#theres-some-terminology-to-be-aware-of","title":"There's some terminology to be aware of","text":"<p>Info</p> <p>Although we've been throwing around the term \"window function\", the actual SQL feature that we use to achieve this is the <code>OVER</code> clause.</p> <p>Before going into an example, there's a bit of terminology to clarify.</p> <p>Window functions are functions that can be used with the <code>OVER</code> clause, such as:</p> <ul> <li><code>ROW_NUMBER</code></li> <li><code>LAG</code></li> <li><code>FIRST_VALUE</code></li> </ul> <p>The \"aggregate functions\" we've seen so far (like <code>SUM</code>, <code>AVG</code>, <code>COUNT</code>, etc.) are designed to be used with the <code>GROUP BY</code> clause, but many of them can also be used with the <code>OVER</code> clause. This means that these aggregate functions are also window functions!</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#the-over-clause-is-the-key-to-window-functions","title":"The <code>OVER</code> clause is the key to window functions","text":"<p>So... how do we use window functions?</p> <p>Since window functions don't reduce the number of rows, we use them in the <code>SELECT</code> clause to add a new column to the result set just like we would if we were doing any other kind of column calculation.</p> <p>Specifically, we write the window function followed by the <code>OVER</code> clause, which is followed by a set of parentheses. Inside the parentheses, we can specify the window over which we want to perform the calculation.</p> <p>The following example shows how to get the count of rows in the <code>Person.Person</code> table alongside showing the first few rows and columns:</p> <pre><code>SELECT TOP 5\n    BusinessEntityID,\n    FirstName,\n    LastName,\n    COUNT(*) OVER () AS TotalRows\nFROM Person.Person\nORDER BY BusinessEntityID\n;\n</code></pre> BusinessEntityID FirstName LastName TotalRows 1 Ken S\u00e1nchez 19972 2 Terri Duffy 19972 3 Roberto Tamburello 19972 4 Rob Walters 19972 5 Gail Erickson 19972 <p>The parentheses after <code>OVER</code> are important (even if they're empty). We'll go through what goes inside the parentheses shortly.</p> <p>To confirm that the <code>TotalRows</code> number is correct, we can verify it with a separate query:</p> <pre><code>SELECT COUNT(*) AS TotalRows\nFROM Person.Person\n;\n</code></pre> TotalRows 19972 <p>Looks good!</p> <p>Warning</p> <p>We used the <code>TOP 5</code> in the query with the window function to limit the number of rows returned, so why did we get 19972 instead of 5?</p> <p>This is to do with the order that SQL processes the query, which is (briefly) covered in the logical processing order section -- <code>TOP</code> is processed after <code>OVER</code>!</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#converting-a-subquery-to-a-window-function","title":"Converting a subquery to a window function","text":"<p>Remember the example below from the subqueries section?</p> <pre><code>SELECT TOP 5\n    SalesOrderID,\n    OrderDate,\n    TotalDue,\n    (\n        SELECT AVG(TotalDue)\n        FROM Sales.SalesOrderHeader\n    ) AS AverageTotalDue\nFROM Sales.SalesOrderHeader\n;\n</code></pre> <p>We can rewrite this example to use <code>AVG</code> with <code>OVER</code> instead of the subquery:</p> <pre><code>SELECT TOP 5\n    SalesOrderID,\n    OrderDate,\n    TotalDue,\n    AVG(TotalDue) OVER () AS AverageTotalDue\nFROM Sales.SalesOrderHeader\n;\n</code></pre> <p>Tip</p> <p>We've just seen that two very different features -- subqueries and window functions -- can be used to achieve the same result. The natural question is: which one should you use?</p> <p>The answer is: it depends on the situation. However, my personal preference is to use window functions over subqueries until I have a reason not to.</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#defining-the-partition-of-a-window-function","title":"Defining the partition of a window function","text":"<p>The examples above just specify <code>OVER</code> with empty parentheses. This is the simplest form of the <code>OVER</code> clause, and it means that the window function is applied to all rows in the result set.</p> <p>The output that this produces is equivalent to summarising the entire column, which was proven in the first example by comparing the <code>TotalRows</code> column to the count of rows in the table.</p> <p>However, just like how we can <code>GROUP BY</code> specific columns, we can also specify a window over specific columns. We do this by writing <code>PARTITION BY</code> inside the parentheses of the <code>OVER</code> clause, followed by the column(s) that we want to partition by. Although we write <code>PARTITION BY</code>, this is just like doing <code>GROUP BY</code>!</p> <p>The following example shows how to get the count of rows in the <code>Person.Person</code> table partitioned by the <code>EmailPromotion</code> column:</p> <pre><code>SELECT TOP 10\n    BusinessEntityID,\n    FirstName,\n    LastName,\n    EmailPromotion,\n    COUNT(*) OVER (PARTITION BY EmailPromotion) AS TotalRowsPerEmailPromotion\nFROM Person.Person\nORDER BY BusinessEntityID\n;\n</code></pre> BusinessEntityID FirstName LastName EmailPromotion TotalRowsPerEmailPromotion 1 Ken S\u00e1nchez 0 11158 2 Terri Duffy 1 5044 3 Roberto Tamburello 0 11158 4 Rob Walters 0 11158 5 Gail Erickson 0 11158 6 Jossef Goldberg 0 11158 7 Dylan Miller 2 3770 8 Diane Margheim 0 11158 9 Gigi Matthew 0 11158 10 Michael Raheem 2 3770 <p>Notice that the <code>TotalRowsPerEmailPromotion</code> column shows the count of rows for each <code>EmailPromotion</code> value, and it just repeats that count for each row with the same <code>EmailPromotion</code> value. This is precisely why using <code>PARTITION BY</code> is like using <code>GROUP BY</code> -- it does the grouping just like it would if we were using <code>GROUP BY</code>, but it doesn't reduce the number of rows!</p> <p>Tip</p> <p>When we use <code>PARTITION BY</code> in a window function, we're splitting the result set into partitions based on the column(s) that we specify. The window function is then applied to each partition separately.</p> <p>Success</p> <p>When we create partitions, this is like using Excel's \"IF\" summary functions over an entire column, such as <code>=SUMIF(A:A, A2)</code>.</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#there-are-two-other-ways-to-use-window-functions","title":"There are two other ways to use window functions","text":"<p>The examples above show how to use window functions over different partitions (including a single partition, the entire table).</p> <p>Other window functions are designed to be used with the rows considered in some order, so we can also specify <code>ORDER BY</code> inside the parentheses of the <code>OVER</code> clause.</p> <p>A great example of this is the <code>LAG</code> function which looks \"one row up\" based on the order that we specify. For example, the following query shows the first few people in the <code>Person.Person</code> table with the first names of the person who came before them (based on the <code>BusinessEntityID</code> column):</p> <pre><code>SELECT TOP 5\n    BusinessEntityID,\n    FirstName,\n    LastName,\n    LAG(FirstName) OVER (ORDER BY BusinessEntityID) AS PreviousFirstName\nFROM Person.Person\nORDER BY BusinessEntityID\n;\n</code></pre> BusinessEntityID FirstName LastName PreviousFirstName 1 Ken S\u00e1nchez null 2 Terri Duffy Ken 3 Roberto Tamburello Terri 4 Rob Walters Roberto 5 Gail Erickson Rob <p>This is just like using a relative cell reference in Excel!</p> <p>Although this isn't a super helpful example, this demonstrates a case where we need to tell SQL which order to use to understand \"previous\" and \"next\" rows. There are technical reasons for it that we won't go into, but SQL will not assume any order unless we specify it.</p> <p>With this in mind, there are two types of windows that we can specify:</p> <ul> <li>Cumulative windows, which are things like \"all rows up to this one\" and are useful for calculating running totals</li> <li>Sliding windows, which are things like \"the last three rows\" and are useful for calculating moving averages</li> </ul>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#cumulative-windows-are-great-for-running-totals","title":"Cumulative windows are great for running totals","text":"<p>One of the most common things to do in Excel is to calculate running totals.</p> <p>We can do this in SQL too by using <code>SUM</code> with the <code>OVER</code> clause, making sure that we specify a row order:</p> <pre><code>SELECT TOP 10\n    SalesOrderID,\n    TotalDue,\n    SUM(TotalDue) OVER (ORDER BY SalesOrderID) AS RunningTotal\nFROM Sales.SalesOrderHeader\nORDER BY SalesOrderID\n;\n</code></pre> SalesOrderID TotalDue RunningTotal 43659 23153.2339 23153.2339 43660 1457.3288 24610.5627 43661 36865.8012 61476.3639 43662 32474.9324 93951.2963 43663 472.3108 94423.6071 43664 27510.4109 121934.0180 43665 16158.6961 138092.7141 43666 5694.8564 143787.5705 43667 6876.3649 150663.9354 43668 40487.7233 191151.6587 <p>There are a few ways that you could do this in Excel. The SQL approach is just like using the formula <code>=SUM($B$2:B2)</code> in cell <code>C2</code> and dragging it down (assuming that the <code>TotalDue</code> column is in column <code>B</code> and the <code>RunningTotal</code> column is in column <code>C</code>).</p> <p>In contrast, if we didn't specify <code>ORDER BY</code> inside the parentheses of the <code>OVER</code> clause, the <code>SUM</code> would be calculated over the entire table:</p> <pre><code>SELECT TOP 10\n    SalesOrderID,\n    TotalDue,\n    SUM(TotalDue) OVER () AS RunningTotal  /* This is now a misnomer */\nFROM Sales.SalesOrderHeader\nORDER BY SalesOrderID\n;\n</code></pre> SalesOrderID TotalDue RunningTotal 43659 23153.2339 123216786.1159 43660 1457.3288 123216786.1159 43661 36865.8012 123216786.1159 43662 32474.9324 123216786.1159 43663 472.3108 123216786.1159 43664 27510.4109 123216786.1159 43665 16158.6961 123216786.1159 43666 5694.8564 123216786.1159 43667 6876.3649 123216786.1159 43668 40487.7233 123216786.1159 <p>This is quite a different result!</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#sliding-windows-are-great-for-moving-averages","title":"Sliding windows are great for moving averages","text":"<p>Another common thing to do in Excel is to calculate moving averages.</p> <p>We can do this in SQL too by using <code>AVG</code> with the <code>OVER</code> clause, making sure that we specify a row order and a window size. The \"window size\" is some more new syntax, so let's go through an example to see how it works.</p> <p>The following query shows the first few orders in the <code>Sales.SalesOrderHeader</code> table with the moving average of the <code>TotalDue</code> column over the last three orders (based on the <code>SalesOrderID</code> column):</p> <pre><code>SELECT TOP 10\n    SalesOrderID,\n    TotalDue,\n    AVG(TotalDue) OVER (\n        ORDER BY SalesOrderID\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n    ) AS MovingAverage\nFROM Sales.SalesOrderHeader\nORDER BY SalesOrderID\n;\n</code></pre> SalesOrderID TotalDue MovingAverage 43659 23153.2339 23153.2339 43660 1457.3288 12305.2813 43661 36865.8012 20492.1213 43662 32474.9324 23599.3541 43663 472.3108 23271.0148 43664 27510.4109 20152.5513 43665 16158.6961 14713.8059 43666 5694.8564 16454.6544 43667 6876.3649 9576.6391 43668 40487.7233 17686.3148 <p>To compare this to Excel, this is just like using the formula <code>=AVERAGE(B2:B4)</code> in cell <code>C4</code> and dragging it down (assuming that the <code>TotalDue</code> column is in column <code>B</code> and the <code>MovingAverage</code> column is in column <code>C</code>).</p> <p>To define the sliding window (the window size), we wrote:</p> <pre><code>ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n</code></pre> <p>This sounds a bit funny, but should be fairly intuitive:</p> <ul> <li>The <code>ROWS BETWEEN</code> tells SQL that we're going to define a window based on the number of rows</li> <li>The <code>2 PRECEDING</code> means \"two rows before the current row\"</li> <li>The <code>CURRENT ROW</code> part is clear and means \"the current row\" \ud83d\ude1d</li> </ul> <p>Altogether, this means \"the last three rows\".</p> <p>We could also look a few rows after the current row by using <code>FOLLOWING</code> instead of <code>PRECEDING</code>; the following window would be \"the current row and the next two rows\":</p> <pre><code>ROWS BETWEEN CURRENT ROW AND 2 FOLLOWING\n</code></pre> <p>In fact, we can also specify the cumulative window that we saw earlier by using <code>UNBOUNDED PRECEDING</code> (this is the default window size):</p> <pre><code>ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n</code></pre> <p>Warning</p> <p>The syntax for defining window functions is actually very flexible, and there are a few different ways to specify the window. The examples above are just the most common ways to do it to keep things simple for this course.</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#define-common-windows-with-the-window-clause","title":"Define common windows with the <code>WINDOW</code> clause","text":"<p>If you find yourself using the same window definition in multiple places of the same statement, you can define it once in the <code>WINDOW</code> clause and then reference it by name:</p> <pre><code>SELECT TOP 10\n    SalesOrderID,\n    AVG(SubTotal) OVER LastThreeSalesOrderIDs AS SubTotalMovingAverage,\n    AVG(TaxAmt) OVER LastThreeSalesOrderIDs AS TaxAmtMovingAverage,\n    AVG(Freight) OVER LastThreeSalesOrderIDs AS FreightMovingAverage,\n    AVG(TotalDue) OVER LastThreeSalesOrderIDs AS TotalDueMovingAverage\nFROM Sales.SalesOrderHeader\nWINDOW LastThreeSalesOrderIDs AS (\n    ORDER BY SalesOrderID\n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n)\n</code></pre> SalesOrderID SubTotalMovingAverage TaxAmtMovingAverage FreightMovingAverage TotalDueMovingAverage 43659 20565.6206 1971.5149 616.0984 23153.2339 43660 10929.9367 1047.8816 327.4630 12305.2813 43661 18195.4507 1749.8442 546.8263 20492.1213 43662 20951.0868 2017.7275 630.5398 23599.3541 43663 20659.4888 1989.7341 621.7919 23271.0148 43664 17894.8655 1720.1416 537.5442 20152.5513 43665 13068.2796 1253.7343 391.7919 14713.8059 43666 14613.9565 1402.4365 438.2614 16454.6544 43667 8505.4476 816.1459 255.0456 9576.6391 43668 15702.5759 1511.4201 472.3188 17686.3148"},{"location":"from-excel-to-sql/main-concepts/window-functions/#you-can-use-partition-by-and-order-by-together","title":"You can use <code>PARTITION BY</code> and <code>ORDER BY</code> together","text":"<p>Wherever you're defining a window, you can use <code>PARTITION BY</code> and <code>ORDER BY</code> together to define the window.</p> <p>There are a few use-cases for this, but a great one is to compute within-year running totals.</p> <p>Consider the following query which shows the quarterly sales totals for 2012 and 2013:</p> <pre><code>SELECT\n    YEAR(OrderDate) AS OrderYear,\n    DATEPART(QUARTER, OrderDate) AS OrderQuarter,\n    SUM(TotalDue) AS TotalSales\nFROM Sales.SalesOrderHeader\nWHERE YEAR(OrderDate) IN (2012, 2013)\nGROUP BY\n    YEAR(OrderDate),\n    DATEPART(QUARTER, OrderDate)\nORDER BY\n    OrderYear,\n    OrderQuarter\n;\n</code></pre> OrderYear OrderQuarter TotalSales 2012 1 9443736.8161 2012 2 9935495.1729 2012 3 10164406.8281 2012 4 8132061.4949 2013 1 8771886.3577 2013 2 12225061.3830 2013 3 14339319.1851 2013 4 13629621.0374 <p>We'll whack this into a CTE to make using it easier, and then we can use the <code>ORDER BY</code> and <code>PARTITION BY</code> clauses to calculate the running total for each year:</p> <pre><code>WITH YearlySales AS (\n    SELECT\n        YEAR(OrderDate) AS OrderYear,\n        DATEPART(QUARTER, OrderDate) AS OrderQuarter,\n        SUM(TotalDue) AS TotalSales\n    FROM Sales.SalesOrderHeader\n    WHERE YEAR(OrderDate) IN (2012, 2013)\n    GROUP BY\n        YEAR(OrderDate),\n        DATEPART(QUARTER, OrderDate)\n)\n\nSELECT\n    OrderYear,\n    OrderQuarter,\n    TotalSales,\n    SUM(TotalSales) OVER (\n        PARTITION BY OrderYear\n        ORDER BY OrderQuarter\n    ) AS WithinYearRunningTotal\nFROM YearlySales\nORDER BY\n    OrderYear,\n    OrderQuarter\n;\n</code></pre> OrderYear OrderQuarter TotalSales WithinYearRunningTotal 2012 1 9443736.8161 9443736.8161 2012 2 9935495.1729 19379231.9890 2012 3 10164406.8281 29543638.8171 2012 4 8132061.4949 37675700.3120 2013 1 8771886.3577 8771886.3577 2013 2 12225061.3830 20996947.7407 2013 3 14339319.1851 35336266.9258 2013 4 13629621.0374 48965887.9632 <p>Super simple!</p>"},{"location":"from-excel-to-sql/main-concepts/window-functions/#further-reading","title":"Further reading","text":"<p>Check out the official Microsoft documentation for more information on the <code>OVER</code> clause at:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/queries/select-over-clause-transact-sql</li> </ul> <p>Microsoft SQL Server splits the window functions into two categories (other than aggregate functions), ranking functions and analytic functions:</p> <ul> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/ranking-functions-transact-sql</li> <li>https://learn.microsoft.com/en-us/sql/t-sql/functions/analytic-functions-transact-sql</li> </ul> <p>The video version of this content is also available at:</p> <ul> <li>https://youtu.be/8e4mQfEDJDk</li> </ul>"}]}